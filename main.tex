\documentclass[a4paper]{scrreprt}
\usepackage[utf8]{inputenc}
\usepackage[german]{babel}
\usepackage{amsmath}
\usepackage{amsthm}
\usepackage[backend=biber,style=authortitle]{biblatex}
\usepackage[babel]{csquotes}
\usepackage{tikz}
\usepackage{geometry}
\geometry{
bottom=25mm,
top=20mm
}

\newtheorem{definition}{Definition}
\newtheorem{Satz}{Satz}
\theoremstyle{definition}
\newtheorem{example}{Beispiel}

\addbibresource{literature.bib}

\DeclareMathOperator\Min{Min}

\title{Untere Schranken für die Abfragekomplexität 
       monotoner symmetrischer Eigenschaften}
\subtitle{Facharbeit}
\author{Erik Diessel}
\begin{document}

\maketitle

\begin{abstract}
Diese Facharbeit beschäftigt sich mit unteren Schranken
für die Abfragekomplexität von monotonen symmetrischen
Eigenschaften von Bitfolgen, besonders für Graph-Eigenschaften.
\end{abstract}

\tableofcontents

\chapter{Einleitung}
Die Frage, welche Komplexität ein Problem hat, d.h.
wie viele Ressourcen ein Algorithmus aufbringen muss,
um ein Problem zu lösen, ist eine der dominierenden
Fragestellungen der theoretischen Informatik.
Der bekannteste Fall ist hier die Frage, ob die beiden
Komplexitätsklassen $P$ und $NP$ identisch sind. Diese
Frage dreht sich um die Zeitkomplexität, die bestimmte
Probleme benötigen. Obwohl dies seit mehr als 40 Jahren
mit großem Aufwand untersucht wird, hat man noch
immer keine Lösung gefunden und es wird vermutet, dass
man auch nicht mit einer Lösung in der nahen Zukunft
rechnen kann \footnote{\cite{PvsNP}}.
Obwohl diese Fragestellung ursprünglich aus der
Informatik stammt, gilt sie inzwischen als eines der
größten ungelösten Probleme der Mathematik. Das Clay
Mathematics Institute stufte es als ein ``Millenium Problem``
der Mathematik ein und hat einen Preis von
1 Million Dollar für seine Lösung ausgelobt
\footnote{vgl. die offizielle Problembeschreibung:
\cite{PvsNPOfficial}}. \\
Die Komplexität eines Problems zu ermitteln hat
große Relevanz für die Praxis, da so die Entwickler
von Algorithmen wissen, wie effizient ein Algorithmus
theoretisch überhaupt sein kann. \\
Es wird vermutet, dass $P\neq NP$ gilt. Um dies zu beweisen
müsste man eine untere Schranke für die Zeitkomplexität
gewisser Probleme finden. Bis heute sind jedoch
keine adäquaten Methoden bekannt. \\
In dieser Facharbeit beschäftigen wir uns daher mit
der  Abfragekomplexität von Eigenschaften. Im Gegensatz
zur Zeitkomplexität ist es hier möglich gute
untere Schranken zu beweisen. Die Entwicklung
neuer Methoden für diesen ''einfachen'' Fall ermöglicht
es vielleicht später, diese, in angepaster Form, auf
die Zeitkomplexität anzuwenden.\\
Im Kontext von ungerichteten Graphen
ist die Abfragekomplexität die Anzahl
an Abfragen der Form ''Besteht eine Kante zwischen
der Ecke $u$ und der Ecke $v$ ?'', die ein Algorithmus
benötigt, um zu entscheiden, ob ein gegebener Graph
eine Eigenschaft erfüllt. Eine Graph-Eigenschaft ist
dabei unabhängig von der konkreten Benennung der Knoten.
Von Rivest und Vuillemin wurde gezeigt,
dass die Abfragekomplexität
im Fall von monotonen Graph-Eigenschaften, die beim 
Hinzufügen von Kanten erhalten bleiben, asymptotisch
quadratisch in der Anzahl der Knoten
ist \footnote{\cite{Rivest}}. Für die von
ihnen gezeigte untere Schranke für die Komplexität
$C(P_n) \geq \frac{1}{16}n^2$ wird bis heute noch
versucht, den konstanten Faktor zu erhöhen. Die bisher beste
untere allgemeine Schranke wurde von Scheidweiler
und Triesch 2013 gezeigt\footnote{\cite{Scheidweiler}}:
$C(P_n) \geq \frac{2}{3}n^2 - o(n^2)$.


\chapter{Die Abfragekomplexität von monotonen Graph-Eigenschaften}
\section{Grundlegende Definitionen}
Im graphentheoretischen Teil folgen wir größtenteils
der Notation eines Standardwerkes der Graphentheorie \footnote{\cite{diestel}}. \\
Mit $\mathcal{G}_n$ bezeichnen wir die Menge aller
(ungerichteten) Graphen mit $n$ Ecken. \\
Den vollständigen Graphen auf $n$ Ecken bezeichnen wir
mit $K_n$. \\
Ist $G \in \mathcal{G}_n$ ein Subgraph von $G' \in \mathcal{G}_n$,
so schreiben wir $G \subseteq G$ oder $G' \supseteq G$. Ist $G$ ein
echter Subgraph von $G'$ (d.h. $E(G) \neq E(G')$), dann schreiben
wir $G \subset G'$ bzw. $G' \subset G$.


\begin{definition}[Graph-Eigenschaft]
Eine Teilmenge $P_n \subseteq \mathcal{G}_n$ der Graphen mit
$n$ Ecken heißt \emph{Graph-Eigenschaft auf $n$ Ecken},
wenn sie invariant unter Isomorphie ist,
d.h. wenn für zwei isomorphe Graphen $G, G'$ gilt:
$G \in P \iff G' \in P$.
\end{definition}
Statt $G \in P_n$ sagen wir auch: $G$ erfüllt die Eigenschaft $P_n$.


\begin{definition}[Monotone Graph-Eigenschaft]
Eine Graph-Eigenschaft $P_n$ heißt \emph{monoton}, wenn das
Hinzufügen von Kanten die Eigenschaft erhält,
d.h. wenn ein Graph
$G' \in \mathcal{G}_n$ ein Supergraph von
$G \in \mathcal{G}_n$ ist, so gilt 
$G \in P_n \implies G' \in P_n$.
\end{definition}

\begin{example}[Monotone Graph-Eigenschaft]
\label{exmpl:Monotonie}
Wir betrachten die folgende Graph-Eigenschaft 
$P_4 \subseteq \mathcal{G}_4$ auf $4$ Ecken:
$$P_4 := \{ G \in \mathcal{G}_4 \ | \ G \text{ enthält den Subgraphen } K_3 \}$$
Diese Eigenschaft ist \emph{monoton}, da wenn 
$G \in P_4$ gilt, $G$ den Subgraphen $K_3$
enthält, woraus folgt, dass auch jeder Supergraph $G'\supseteq G$
den Subgraphen $K_3$ enthält. 
\end{example}

Im folgenden werden wir uns auf monotone Graph-Eigenschaften beschränken.
Um einige degenerierte Fälle auszuschließen, beschränken
wir uns auch auf \emph{nichttriviale} Eigenschaften.
\begin{definition}[Nichttriviale Graph-Eigenschaft]
Eine monotone Graph-Eigenschaft $P_n$ heißt \emph{nichttrivial},
wenn der leere Graph $E_n$ nicht in $P_n$ enthalten ist und
$P_n\neq \emptyset$ gilt.
\end{definition}
Die Bedingung $E_n \notin P_n$ bedeutet, dass $P_n$ nicht
alle Graphen auf $n$ Ecken beinhaltet. In diesem Fall würde
es keinen Sinn machen, einen Algorithmus berechnen zu lassen,
ob ein gegebener Graph die Eigenschaft erfüllt, da das Ergebnis
unabhängig vom Graphen wäre.

\begin{definition}[Minimaler Graph]
Ein Graph $G \in \mathcal{G}_n$ heißt
\emph{minimaler Graph der montonen Graph-Eigenschaft $P_n$},
wenn $G \in P_n$ gilt, aber jeder echte Subgraph 
$G' \subset G$ die Eigenschaft $P_n$ nicht erfüllt.
\end{definition}

In Beispiel \ref{exmpl:Monotonie} wäre 
\begin{center}
\begin{tikzpicture}[main_node/.style={circle,fill=black,minimum size=0.8em,inner sep=2pt]}]

    \node[main_node] (1) at (0,0) {};
    \node[main_node] (2) at (-0.5, -0.75)  {};
    \node[main_node] (3) at (0.5, -0.75) {};
    \node[main_node] (4) at (1.2, -0.3) {};

    \draw (1) -- (2) -- (3) -- (1);
\end{tikzpicture}
\end{center}

der bis auf Isomorphie eindeutige \emph{minimale} 
Graph von $P_4$, da das Entfernen einer Kante
den Subgraphen $K_3$ zerstören würde.

\begin{definition}[Minimale Graphenmenge $\Min(P_n)$]
Die Menge der minimalen Graphen der monotonen Graph-Eigenschaft
$P_n$ heißt:
$$\Min(P_n) := \{ G\in P_n \ | \ G \text{ ist minimal } \}$$
\end{definition}

Die Menge $\Min(P_n)$ charakterisiert die
Eigenschaft vollständig, wie folgender Satz zeigt:

\begin{Satz}[$\Min(P_n)$ legt $P_n$ eindeutig fest]
Sind $P_n, P'_n \subseteq \mathcal{G}_n$ zwei monotone 
Graph-Eigenschaften, so gilt
$\Min(P_n) = \Min(P'_n)$ genau dann, wenn $P_n = P'_n$.
\end{Satz}
\begin{proof} \hfill
\begin{description}
\item[$\boldsymbol{\Min(P_n) = \Min(P'_n) \implies P_n = P'_n}$]
\hfill \\
Sei $G \in P_n$ beliebig. Wir zeigen dann, dass auch $G \in P'_n$
gilt. Aus Symmetriegründen folgt dann, dass für ein beliebiges 
$G' \in P'_n$ gilt: $G' \in P_n$, woraus die Gleichheit der
Eigenschaften $P_n = P'_n$ folgt. \\
Wir setzen $G_0 := G$. Solange es möglich ist, wählen wir nun
eine Kante $e \in E(G_i)$, sodass für $G_{i+1} := G_i - e$  
weiterhin $G_{i+1} \in P_n$ gilt. \\
Es gibt nun ein $i$, für das es nicht mehr möglich ist,
aus $G_i$ eine Kante zu entfernen und dabei die Eigenschaft
zu erhalten (spätestens, wenn $G_i$ leer ist).
Der Graph $G_i$ ist dann per Konstruktion ein minimaler
Graph, folglich gilt $G_i \in \Min(P_n)$. Aufgrund der
Voraussetzung $\Min(P_n) = \Min(P'_n)$ gilt auch 
$G_i \in \Min(P'_n)$. Da die Eigenschaft $P'_n$ monoton ist,
und $G_i \subseteq G$, gilt dann auch $G_i \in P'_n$,
wie gefordert.
\item[$\boldsymbol{P_n = P'_n \implies \Min(P_n) = \Min(P'_n)}$]
\hfill \\
Wegen $P_n = P'_n$ ist $G \in \mathcal{G}_n$ offensichtlich
genau dann ein minimaler Graph von $P_n$, wenn $G$ ein 
minimaler Graph von $P'_n$ ist. Daraus folgt 
$\Min(P_n) = \Min(P'_n)$.
\end{description}
\end{proof}
Der vorherige Satz ermöglicht uns, eine
monotone Eigenschaft einfacher zu beschreiben. \\

Wir führen nun die ersten algorithmischen Begriffe ein. \\
Da wir uns nur mit der Abfragekomplexität beschäftigen,
vereinfachen wir unser Berechnungsmodell: \\
Einen Algorithmus stellen wir als Entscheidungsbaum dar.
Die Knoten sind hierbei mit einer Kante bezeichnet, die
abgefragt wird. Jeder Knoten hat zwei Kante, die mit
''ja'' und ''nein'' beschriftet sind, dies steht für
die Antwort auf die Abfrage. Die Blatt-Knoten sind
zusätzlich mit ''ja'' und ''nein'' beschriftet,
dies steht für den Rückgabewert des Algorithmus.
Zu beachten ist, dass der Algorithmus nur für eine
Eingabegröße, das heißt für eine Eckenanzahl $n$,
festgelegt ist.\\
Wir sagen nun, dass ein Algorithmus $\mathcal{A}$
die Graph-Eigenschaft $P_n$ \emph{entscheidet}, wenn
für jeden Input $G \in \mathcal{G}_n$ der Blatt-Knoten
des zugehörigen Pfades des Entscheidungsbaums genau
dann mit ''ja'' beschriftet ist, wenn $G \in P_n$ gilt.

\begin{example}
\label{exmpl:decisionTree}
\begin{tikzpicture}

\end{tikzpicture}
Der hier dargestellte Entscheidungsbaum entscheidet
die monotone Graph-Eigenschaft 
$P_3 := \big\{ G \in \mathcal{G}_n \ \big| \ |E(G)| \geq 2 \big\}$,
d.h. ob der Graph mindestens $2$ Kanten hat.
Man sieht, dass die Anzahl an Abfragen von
dem Input abhängt.
\end{example}

Wir können nun unseren zentralen Begriff definieren.
\begin{definition}[Abfragekomplexität für einen Input]
Die \emph{Abfragekomplexität} $C(\mathcal{A},G)$ eines
Algorithmus $\mathcal{A}$ für den Input $G$ ist
die Länge des zu $G$ gehörenden Pfades des
Entscheidungsbaumes.
\end{definition}
Die Abfragekomplexität eines Algorithmus definieren
wir nun als Worst-Case-Komplexität.
\begin{definition}[Abfragekomplexität eines Algorithmus]
Die \emph{Abfragekomplexität} $C(\mathcal{A})$ eines
Algorithmus $\mathcal{A}$ ist
$$ C(\mathcal{A}) := \max_{G \in \mathcal{G}_n} C(\mathcal{A},G)$$
\end{definition}
Der in Beispiel \ref{exmpl:decisionTree} dargestellte
Algorithmus hat eine Abfragekomplexität von $3$, da
der längste Pfad die Länge $3$ gibt. \\
Nun können wir die Abfragekomplexität unabhängig
von einem bestimmten Algorithmus definieren.
\begin{definition}
Die \emph{Abfragekomplexität} $C(P_n)$ einer Graph-Eigenschaft
$P_n$ ist
$$ C(P_n) := \min_{\mathcal{A} \text{ entscheidet } P_n} C(\mathcal{A})$$
\end{definition}

\printbibliography
\end{document}
