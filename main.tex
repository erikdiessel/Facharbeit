\documentclass[a4paper]{scrreprt}
\usepackage[utf8]{inputenc}
\usepackage[ngerman]{babel}
\usepackage{amsmath}
\usepackage{amsthm}
\usepackage[backend=biber,style=authortitle]{biblatex}
\usepackage[babel]{csquotes}
\usepackage{tikz}
\usepackage{amsfonts}
\usepackage{blindtext}
\usepackage{hyperref}
\usepackage{geometry}
\usepackage{framed} % TEST
\geometry{
bottom=25mm,
top=20mm,
left=20mm,
right=20mm
}

\newtheorem{definition}{Definition}
\newtheorem{Satz}[definition]{Satz}
\newtheorem{conjecture}[definition]{Vermutung}
\newtheorem{corollary}[definition]{Korollar}
\theoremstyle{definition}
\newtheorem{examplex}{Beispiel}

\newenvironment{example}[1]
{ \begin{leftbar} \begin{examplex}#1}
{ \end{examplex} \ignorespacesafterend \end{leftbar} }

\addbibresource{literature.bib}

\DeclareMathOperator\Min{Min}
\DeclareMathOperator\Dupl{Dupl}

\newcommand{\Square}{
\begin{tikzpicture}[main_node/.style={circle,fill=black},
inner sep=1.5pt, baseline=2pt]

    \node[main_node] (1) at (0,0) {};
    \node[main_node] (2) at (0.35, 0)  {};
    \node[main_node] (3) at (0.35, 0.35) {};
    \node[main_node] (4) at (0, 0.35) {};

    \draw (1) -- (2) -- (3) -- (4) -- (1);
\end{tikzpicture}
}

\title{Untere Schranken für die Abfragekomplexität 
       monotoner symmetrischer Eigenschaften}
\subtitle{Facharbeit}
\author{Erik Diessel}
\begin{document}

\maketitle

\begin{abstract}
\begin{center}
\bf{Kurzfassung}
\end{center}
Diese Facharbeit beschäftigt sich mit unteren Schranken
für die Abfragekomplexität von monotonen symmetrischen
Eigenschaften von Bitfolgen, besonders für Graph-Eigenschaften.
\end{abstract}

\tableofcontents
\thispagestyle{empty}

\chapter{Einleitung}
Die Frage, welche Komplexität ein Problem hat, d.h.
wie viele Ressourcen ein Algorithmus aufbringen muss,
um ein Problem zu lösen, ist eine der dominierenden
Fragestellungen der theoretischen Informatik.
Der bekannteste Fall ist hier die Frage, ob die beiden
Komplexitätsklassen $P$ und $NP$ identisch sind. Diese
Frage dreht sich um die Zeitkomplexität, die bestimmte
Probleme benötigen. Die Komplexität eines Problems zu ermitteln hat
große Relevanz für die Praxis, da sie die theoretischen
Grenzen für die Performance eines Algorithmus aufzeigen. \\
Die Wichtigkeit dieser ursprünglich aus der Informatik
stammenden Fragestellung zeigt sich darin, dass das Clay
Mathematics Institute es als ein "`Millenium Problem"'
der Mathematik eingestuft und einen Preis von
1 Million Dollar für seine Lösung ausgelobt hat.
\footnote{vgl. die offizielle Problembeschreibung:
\cite{PvsNPOfficial}}. \\
Um die vermutete Ungleichheit $P\neq NP$ zu zeigen,
muss eine untere Schranke für die Komplexität einiger
Probleme gezeigt werden. Bis heute scheint dies jedoch
in weiter Ferne.\footnote{\cite{PvsNP}}
In dieser Facharbeit beschäftigen wir uns daher mit
der  Abfragekomplexität von Eigenschaften. Im Gegensatz
zur Zeitkomplexität ist es hier möglich gute
untere Schranken zu beweisen. Die Entwicklung
neuer Methoden für untere Schranken bei diesem "`einfachen"' Fall,
führt dann eventuell zu neuen Impulsen für untere
Schranken bei der Zeitkomplexität. \\
Im Kontext von ungerichteten Graphen
ist die Abfragekomplexität die Anzahl
an Abfragen der Form "`Besteht eine Kante zwischen
der Ecke $u$ und der Ecke $v$ ?"', die ein Algorithmus
benötigt, um zu entscheiden, ob ein gegebener Graph
eine Eigenschaft erfüllt. Eine Graph-Eigenschaft ist
dabei unabhängig von der konkreten Benennung der Knoten. \\
Von Rivest und Vuillemin wurde gezeigt,
dass die Abfragekomplexität
im Fall von monotonen Graph-Eigenschaften, die beim 
Hinzufügen von Kanten erhalten bleiben, asymptotisch
quadratisch in der Anzahl der Knoten
ist\footnote{\cite{Rivest}}: $C(P_n) \geq \frac{1}{16}n^2$.
Die Aanderaa-Karp-Rosenberg-Vermutung, dass im Worst-Case
zum Entscheiden einer monotonen Graph-Eigenschaft
alle Kanten abgefragt werden müssen, d.h. dass
$C(P_n)=\binom{n}{2}$ gilt, ist jedoch schon
seit Jahrzehnten offen. Mit dieser Facharbeit
wollen wir nun an einer Weiterentwicklung der
Methoden mitwirken, damit ein Beweis dieser Vermutung
weiter in die Nähe rückt.

Diese Arbeit ist folgendermaßen aufgebaut:
Wir definieren zunächst die Abfragekomplexität
von Graph-Eigenschaften im deterministischem und
randomisiertem Fall. Nachdem wir die Konzepte
"`minimaler Graph"' und kantenmaximaler Graph
eingeführt haben, zeigen wir einige untere Schranken
für die Abfragekomplexität, die auf diesen Begriffen
basieren. Im nächsten Kapitel zeigen wir dann einige
konkretere untere Schranken für eine Vielzahl von
Graph-Eigenschaften. Nachdem wir die Grenzen 
dieses Ansatzes ausgeleuchtet haben, verallgemeinern
wir das Konzept der Graph-Eigenschaften auf 
symmetrische Eigenschaften von Bitfolgen. Für
diese Fälle zeigen wir einige untere Schranken.
Danach formulieren wir die Begriffe "`Algorithmus"'
und "`Abfragekomplexität"' nocheinmal algebraisch, um
in einem letzten Abschnitt
einige algebraische Ansätze für Methoden vorstellen zu
können, die noch bessere untere Schranken ermöglichen könnten.

\chapter{Die Abfragekomplexität von monotonen Graph-Eigenschaften}
\section{Grundlegende Definitionen}
\subsection{Graph-Eigenschaften}
Im graphentheoretischen Teil folgen wir größtenteils
der Notation eines Standardwerkes der Graphentheorie \footnote{\cite{diestel}}. \\
Mit $\mathcal{G}_n$ bezeichnen wir die Menge aller
(ungerichteten) Graphen mit $n$ Ecken. \\
Den vollständigen Graphen auf $n$ Ecken bezeichnen wir
mit $K_n$. \\
Ist $G \in \mathcal{G}_n$ ein Subgraph von $G' \in \mathcal{G}_n$,
so schreiben wir $G \subseteq G$ oder $G' \supseteq G$. Ist $G$ ein
echter Subgraph von $G'$ (d.h. $E(G) \neq E(G')$), dann schreiben
wir $G \subset G'$ bzw. $G' \subset G$.
Für $G' = (V, E \cup \{e\})$ schreiben wir vereinfachend
$G' = G + E$ und für $G' = (V, E \backslash \{e\})$ vereinfachend
$G' = G - e$.


\begin{definition}[Graph-Eigenschaft]
Eine Teilmenge $P_n \subseteq \mathcal{G}_n$ der Graphen mit
$n$ Ecken heißt \emph{Graph-Eigenschaft auf $n$ Ecken},
wenn sie invariant unter Isomorphie ist,
d.h. wenn für zwei isomorphe Graphen $G, G'$ gilt:
$G \in P \iff G' \in P$.
\end{definition}
Statt $G \in P_n$ sagen wir auch: $G$ erfüllt die Eigenschaft $P_n$.


\begin{definition}[Monotone Graph-Eigenschaft]
Eine Graph-Eigenschaft $P_n$ heißt \emph{monoton}, wenn das
Hinzufügen von Kanten die Eigenschaft erhält,
d.h. wenn ein Graph
$G' \in \mathcal{G}_n$ ein Supergraph von
$G \in \mathcal{G}_n$ ist, so gilt 
$G \in P_n \implies G' \in P_n$.
\end{definition}

\begin{example}[Monotone Graph-Eigenschaft]
\label{exmpl:Monotonie}
Wir betrachten die folgende Graph-Eigenschaft 
$P_4 \subseteq \mathcal{G}_4$ auf $4$ Ecken:
$$P_4 := \{ G \in \mathcal{G}_4 \ | \ G \text{ enthält den Subgraphen } K_3 \}$$
Diese Eigenschaft ist \emph{monoton}, da wenn 
$G \in P_4$ gilt, $G$ den Subgraphen $K_3$
enthält, woraus folgt, dass auch jeder Supergraph $G'\supseteq G$
den Subgraphen $K_3$ enthält. 
\end{example}

Im folgenden werden wir uns auf monotone Graph-Eigenschaften beschränken.
Um einige degenerierte Fälle auszuschließen, beschränken
wir uns auch auf \emph{nichttriviale} Eigenschaften.
\begin{definition}[Nichttriviale Graph-Eigenschaft]
Eine monotone Graph-Eigenschaft $P_n$ heißt \emph{nichttrivial},
wenn der leere Graph $E_n$ nicht in $P_n$ enthalten ist und
$P_n\neq \emptyset$ gilt.
\end{definition}
Die Bedingung $E_n \notin P_n$ bedeutet, dass $P_n$ nicht
alle Graphen auf $n$ Ecken beinhaltet. In diesem Fall würde
es keinen Sinn machen, einen Algorithmus berechnen zu lassen,
ob ein gegebener Graph die Eigenschaft erfüllt, da das Ergebnis
unabhängig vom Graphen wäre.

\begin{definition}[Minimaler Graph]
Ein Graph $G \in \mathcal{G}_n$ heißt
\emph{minimaler Graph der montonen Graph-Eigenschaft $P_n$},
wenn $G \in P_n$ gilt, aber jeder echte Subgraph 
$G' \subset G$ die Eigenschaft $P_n$ nicht erfüllt.
\end{definition}

In Beispiel \ref{exmpl:Monotonie} ist
\begin{center}
\begin{tikzpicture}[main_node/.style={circle,fill=black,minimum size=0.8em,inner sep=2pt]}]

    \node[main_node] (1) at (0,0) {};
    \node[main_node] (2) at (-0.5, -0.75)  {};
    \node[main_node] (3) at (0.5, -0.75) {};
    \node[main_node] (4) at (1.2, -0.3) {};

    \draw (1) -- (2) -- (3) -- (1);
\end{tikzpicture}
\end{center}

der bis auf Isomorphie eindeutige \emph{minimale} 
Graph von $P_4$, da das Entfernen einer Kante
den Subgraphen $K_3$ zerstören würde.

\begin{definition}[Minimale Graphenmenge $\Min(P_n)$]
Die Menge der minimalen Graphen der monotonen Graph-Eigenschaft
$P_n$ heißt:
$$\Min(P_n) := \{ G\in P_n \ | \ G \textup{ ist minimaler Graph von } P_n\}$$
\end{definition}

Die Menge $\Min(P_n)$ charakterisiert die
Eigenschaft vollständig, wie folgender Satz zeigt:

\begin{Satz}[$\Min(P_n)$ legt $P_n$ eindeutig fest]
Sind $P_n, P'_n \subseteq \mathcal{G}_n$ zwei monotone 
Graph-Eigenschaften, so gilt
$\Min(P_n) = \Min(P'_n)$ genau dann, wenn $P_n = P'_n$.
\end{Satz}
\begin{proof} \hfill
\begin{description}
\item[$\boldsymbol{\Min(P_n) = \Min(P'_n) \implies P_n = P'_n}$]
\hfill \\
Sei $G \in P_n$ beliebig. Wir zeigen dann, dass auch $G \in P'_n$
gilt. Aus Symmetriegründen folgt dann, dass für ein beliebiges 
$G' \in P'_n$ gilt: $G' \in P_n$, woraus die Gleichheit der
Eigenschaften $P_n = P'_n$ folgt. \\
Wir setzen $G_0 := G$. Solange es möglich ist, wählen wir nun
eine Kante $e \in E(G_i)$, sodass für $G_{i+1} := G_i - e$  
weiterhin $G_{i+1} \in P_n$ gilt. \\
Es gibt nun ein $i$, für das es nicht mehr möglich ist,
aus $G_i$ eine Kante zu entfernen und dabei die Eigenschaft
zu erhalten (spätestens, wenn $G_i$ leer ist).
Der Graph $G_i$ ist dann per Konstruktion ein minimaler
Graph, folglich gilt $G_i \in \Min(P_n)$. Aufgrund der
Voraussetzung $\Min(P_n) = \Min(P'_n)$ gilt auch 
$G_i \in \Min(P'_n)$. Da die Eigenschaft $P'_n$ monoton ist,
und $G_i \subseteq G$, gilt dann auch $G_i \in P'_n$,
wie gefordert.
\item[$\boldsymbol{P_n = P'_n \implies \Min(P_n) = \Min(P'_n)}$]
\hfill \\
Wegen $P_n = P'_n$ ist $G \in \mathcal{G}_n$ offensichtlich
genau dann ein minimaler Graph von $P_n$, wenn $G$ ein 
minimaler Graph von $P'_n$ ist. Daraus folgt 
$\Min(P_n) = \Min(P'_n)$.
\end{description}
\end{proof}
Der vorherige Satz ermöglicht uns, eine
monotone Eigenschaft einfacher zu beschreiben. 
Für die monotone Graph-Eigenschaft $P_n\subseteq \mathcal{G}_n$
mit der Menge an minimalen Graphen $\mathcal{H} = \Min(P_n)$
schreiben wir $\operatorname{P}_n(\mathcal{H})$. Die Eindeutigkeit dieser
Schreibweise folgt aus dem vorherigen Satz. \\
Dies macht das Formulieren von Eigenschaften sehr viel einfacher:
Die Eigenschaft aus Beispiel \ref{exmpl:Monotonie} lässt sich
so schreiben als $\operatorname{P}_4(\{K_3\})$.


\subsection{Abfragekomplexität}
\label{sec:queryComplexity}

Wir führen nun die ersten algorithmischen Begriffe ein.
\footnote{vgl. \cite[S.7]{Rivest}}\\
Da wir uns nur mit der Abfragekomplexität beschäftigen,
vereinfachen wir unser Berechnungsmodell: \\
Einen Algorithmus stellen wir als Entscheidungsbaum dar.
Die Knoten sind hierbei mit einer Kante bezeichnet, die
abgefragt wird. Jeder Knoten hat zwei Kante, die mit
''ja'' und ''nein'' beschriftet sind, dies steht für
die Antwort auf die Abfrage. Die Blatt-Knoten sind
zusätzlich mit ''ja'' und ''nein'' beschriftet,
dies steht für den Rückgabewert des Algorithmus.
Zu beachten ist, dass der Algorithmus nur für eine
Eingabegröße, das heißt für eine Eckenanzahl $n$,
festgelegt ist.\\
Wir sagen nun, dass ein Algorithmus $\mathcal{A}$
die Graph-Eigenschaft $P_n$ \emph{entscheidet}, wenn
für jeden Input $G \in \mathcal{G}_n$ der Blatt-Knoten
des zugehörigen Pfades des Entscheidungsbaums genau
dann mit ''ja'' beschriftet ist, wenn $G \in P_n$ gilt.

\begin{example}[Entscheidungsbaum] \ \\*
\label{exmpl:decisionTree}
\begin{center}
\begin{tikzpicture} [
    level 1/.style = {sibling distance=7cm},
    level 2/.style = {sibling distance=3cm}, 
    level 3/.style = {sibling distance=2cm},
    font=\sffamily
]
\tikzstyle{every node}=[draw]

\node [draw] {$(1,2)\in G\,?$}
  child {  node {$(1,3)\in G\,?$} 
    child { node {$G \in P_3$} edge from parent node[left,draw=none] {ja} }
    child { node {$(2,3)\in G\,?$}
      child { node {$G \in P_3$} edge from parent node[left,draw=none] {ja} }
      child { node {$G \notin P_3$} edge from parent node[right,draw=none] {nein} }
      edge from parent node[right,draw=none] {nein} 
    }
    edge from parent node[left,draw=none] {ja}
  }
  child { node {$(2,3)\in G\,?$}
    child { node {$(1,3)\in G\,?$}
      child { node{$G \in P_3$} edge from parent node[left,draw=none] {ja} }
      child { node{$G \notin P_3$} edge from parent node[right,draw=none] {nein} }
      edge from parent node[left,draw=none] {ja}
    }
    child { node {$G \notin P_3$} edge from parent node[right,draw=none] {nein} }
    edge from parent node[right,draw=none] {nein} 
  };
\end{tikzpicture}
\end{center}
Der hier dargestellte Entscheidungsbaum entscheidet
die monotone Graph-Eigenschaft 
${P_3 := \big\{ G \in \mathcal{G}_n \ \big| \ |E(G)| \geq 2 \big\}}$,
d.h. ob der Graph mindestens $2$ Kanten hat.
Man sieht, dass die Anzahl an Abfragen von
dem Input abhängt.
\end{example}

Wir können nun unseren zentralen Begriff definieren.

\begin{definition}[Deterministische Abfragekomplexität]
Die \emph{Abfragekomplexität} $C(\mathcal{A},G)$ eines
Algorithmus $\mathcal{A}$ für den Input $G$ ist
die Länge des zu $G$ gehörenden Pfades des
Entscheidungsbaumes. \\
Die \emph{Abfragekomplexität} $C(\mathcal{A})$ eines
Algorithmus $\mathcal{A}$ ist dann
$$ C(\mathcal{A}) := \max_{G \in \mathcal{G}_n} C(\mathcal{A},G)$$
Die \emph{Abfragekomplexität} $C(P_n)$ einer Graph-Eigenschaft
$P_n\subseteq \mathcal{G}_n$ ist nun
$$ C(P_n) := \min_{\mathcal{A} \ {\rm entscheidet}\  P_n} C(\mathcal{A})$$
\end{definition}

Der in Beispiel \ref{exmpl:decisionTree} dargestellte
Algorithmus hat eine Abfragekomplexität von $3$, da
der längste Pfad die Länge $3$ hat. \\
Die Aanderaa-Karp-Rosenberg lautet nun:
\footnote{vgl. \cite[S.9]{Lovasz}}
\begin{conjecture}[Aanderaa-Karp-Rosenberg]
Jede monotone nichttriviale Graph-Eigenschaft $P_n$
hat eine Abfragekomplexität von
$$C(P_n) = \frac{n(n-1)}{2}$$
\end{conjecture}
Die Aanderaa-Karp-Rosenberg-Vermutung sagt also aus,
das bei allen monotonen Graph-Eigenschaften im Worst-Case
alle Kanten abgefragt werden müssen (denn ein Graph mit
$n$ Ecken hat genau ${\binom{n}{2}=\frac{n(n-1)}{2}}$ Kanten).

\subsection{Randomisierte Abfragekomplexität}

Bisher haben wir uns nur mit \emph{deterministischer}
Abfragekomplexität beschäftigt, d.h. die betrachteten
Algorithmus hatten keinen Zufall zur Verfügung.
Da randomisierte Algorithmen deterministischen Algorithmen
oft überlegen sind, müssen wir dies auch für
die Abfragekomplexität untersuchen.
% Vielleicht Zitat einfügen für
% Problem, bei dem randomisierte Algorithmen klar
% überlegen sind.
Wir definieren hierfür zunächst einen randomisierten
Algorithmus, um dann dessen Komplexität zu definieren
\footnote{vgl. \cite[S.120]{Groeger}}.
\begin{definition}[Randomisierter Algorithmus]
Ein \emph{randomisierter Algorithmus}, der eine
Eigenschaft $P_n$ entscheidet, ist eine
Wahrscheinlichkeitsverteilung von deterministischen
Algorithmen, die $P_n$ entscheiden. Formal: eine Abbildung
$$ p_\mathcal{A}: \{ \mathcal{A} \ \textup {deterministisch} \ | \
         \mathcal{A} \ {\rm entscheidet} \ P_n \} \to \mathbb{R} $$
mit $\sum_\mathcal{A} p_\mathcal{A}(\mathcal{A}) = 1$.
\end{definition}

Das Ausführen eines randomisierten Algorithmus findet
dann so statt: Zu Beginn wird, mit den entsprechenden
Wahrscheinlichkeiten, ein deterministischer Algorithmus
ausgewählt, der dann ausgeführt wird.
Die randomisierte Abfragekomplexität ist dann der
Erwartungswert für die benötigte Anzahl an Abfragen.

\begin{definition}[Randomisierte Abfragekomplexität für einen Input]
\label{def:randComplInput}
Die \emph{randomisierte Abfragekomplexität} $C_R(P_n)$ eines randomisierten
Algorithmus $p_\mathcal{A}$, für den Input $G\in \mathcal{G}_n$, ist:
$$ C_R(p_\mathcal{A}, G) := 
\sum_\mathcal{A} p_\mathcal{A}(\mathcal{A}) \cdot C(\mathcal{A}, G) $$
\end{definition}
Analog definieren wir nun die randomisierte Abfragekomplexität
eines Algorithmus:
\begin{definition}[Randomisierte Abfragekomplexität eines Algorithmus]
Die \emph{randomisierte Abfragekomplexität} eines randomisierten
Algorithmus $\mathcal{A}$ ist:
$$ C_R(\mathcal{A}) := \max_{G\in\mathcal{G}_n} C_R(\mathcal{A}, G) $$
\end{definition}
Analog zum deterministischen Fall können wir nun die
\emph{randomisierte} Abfragekomplexität einer Graph-Eigenschaft
definieren:
\begin{definition}[Randomisierte Abfragekomplexität einer Graph-Eigenschaft]
\label{def:randComplProp}
Die \emph{randomisierte Abfragekomplexität} einer Graph-Eigenschaft
$P_n$ ist:
$$ C_R(P_n) := \min_{\mathcal{A}_R}\ C(\mathcal{A}_R)$$
wobei $\mathcal{A}_R$ aus allen randomisierten Algorithmen,
die $P_n$ entscheiden, gewählt wird.
\end{definition}

\section{Untere Schranken für die Abfragekomplexität}

\subsection{... anhand eines minimalen Graphen}

Wir zeigen nun einige einfache untere Schranken
für die Abfragekomplexität, die auf minimalen
Graphen basieren. Diese Aussagen ermöglichen uns
später, konkretere untere Schranken zu beweisen.
\footnote{Ein ähnlicher Ansatz wird verfolgt von: \cite{Groeger}}
\begin{Satz}[Größe des minimalen Graphen ist untere Schranken]
\label{thm:minDetLowerBound}
Sei $H\in \mathcal{G}_n$ ein minimaler Graph der monotonen
Graph-Eigenschaft $P_n$. Dann gilt für jeden deterministischen
Algorithmus $\mathcal{A}$, der $P_n$ entscheidet:
$$ C(\mathcal{A,H}) \geq |E(H)| $$.
\end{Satz}
\begin{proof}
Wir führen einen Widerspruchsbeweis. \\
Angenommen $ C(\mathcal{A},H) < |E(H)| $.
Dann gibt es eine Kante $e\in H$,
die von $\mathcal{A}$ nicht abgefragt wird. Entfernen wir
diese Kante, so erhalten wir den Graphen $H' = H - e$, der,
da $H$ ein minimaler Graph ist, die Eigenschaft $P$ nicht
erfüllt. $\mathcal{A}$ gibt jedoch für $H$ und $H'$ das gleiche
Ergebnis zurück, da die sie unterscheidende Kante von $\mathcal{A}$
nicht abgefragt wird. Folglich entscheidet $\mathcal{A}$ die
Eigenschaft $P_n$ nicht korrekt. Dies ist ein Widerspruch zur
Voraussetzung. Folglich muss $ C(\mathcal{A,H}) \geq |E(H)| $ gelten. 
\end{proof}
Der Satz sagt nicht nur aus, dass die Abfragekomplexität
der Eigenschaft von unten beschränkt ist, sondern auch, dass
es einen bestimmten Input gibt, für den eine bestimmte Anzahl
an Abfragen benötigt werden, unabhängig davon, welchen Algorithmus
wir wählen. Dies bedeutet, dass ein randomisierter Algorithmus
auch diese Anzahl an Abfragen benötigt:
\begin{corollary}[Minimaler Graph liefert untere Schranke für 
                  randomisierte Abfragekomplexität]
\label{cor:MinGraphRandCompl}
Sei $H\in \mathcal{G}_n$ ein minimaler Graph der monotonen
Graph-Eigenschaft $P_n$. Dann gilt:
$$C_R(P_n) \geq |E(H)|$$.
\end{corollary}
\begin{proof}
Sei $p_\mathcal{A}$ ein beliebiger randomisierter Algorithmus,
der $P_n$ entscheidet.
Nach Definition \ref{def:randComplInput} gilt: 
$ C_R(p_\mathcal{A}, H) = 
\sum_\mathcal{A} p_\mathcal{A}(\mathcal{A}) \cdot C(\mathcal{A}, H) $.
Wegen Satz \ref{thm:minDetLowerBound} gilt $C(\mathcal{A}, H) \geq |E(H)|$
für alle deterministischen Algorithmen $\mathcal{A}$. Einsetzen ergibt:
$$ C_R(p_\mathcal{A}, H) \overset{\textup{Def.} \ref{def:randComplInput}} {=}
\sum_\mathcal{A} p_\mathcal{A}(\mathcal{A}) \cdot C(\mathcal{A}, H) 
\overset{\textup{Satz } \ref{thm:minDetLowerBound}} {\geq}
\sum_\mathcal{A} p_\mathcal{A}(\mathcal{A}) \cdot |E(H)| =
|E(H)| $$
Mit Definition \ref{def:randComplProp} erhalten wir dann
$$ C_R(P_n) \overset{\textup{Def. } \ref{def:randComplProp}} {=} 
\min_{p_\mathcal{A}}\ C(p_\mathcal{A}) \geq |E(H)|$$
\end{proof}

Wie man sieht, kann mit minimalen Graphen einfach untere Schranken
für die Abfragekomplexität zeigen. Die Anzahl an Kanten $|E(H)|$
kann jedoch klein sein, sodass die untere Schranke nicht viel wert ist.
Im folgenden Abschnitt betrachten wir daher ein anderes Konzept.

\subsection{... anhand eines kantenmaximalen Graphen}

Wir führen daher nun das Konzept des kantenmaximalen Graphen ein,
welches gewissermaßen \emph{dual} zum Konzept des minimalen Graphen
ist. Wir wollen damit wieder eine untere Schranke zeigen.
\begin{definition}[Kantenmaximaler Graph
\footnote{vgl. \cite[S.12]{diestel}}]
Ein Graph $G\in \mathcal{G}_n$ heißt \emph{kantenmaximaler Graph}
der monotonen Graph-Eigenschaft $P_n$, wenn $G\notin P_n$ gilt,
aber für alle Kanten $e\notin G$ gilt: $G + e \in P_n$.
\end{definition}
Kantenmaximale Graphen sind also Graphen, die die Eigenschaft
nicht erfüllen, bei dem das Hinzufügen einer beliebigen
Kante aber dafür sorgt, dass die Eigenschaft erfüllt wird.
% Hier vielleicht Beispiel einfügen für kantenmaximalen Graphen ?

\begin{example}[Kantenmaximaler Graph]
Ein kantenmaximaler Graph der Eigenschaft $\operatorname{P}_4(\{K_3\})$
aus Beispiel \ref{exmpl:Monotonie} ist folgender Graph:

\begin{center}
\begin{tikzpicture}[main_node/.style={circle,fill=black,minimum size=0.8em,inner sep=2pt]}]

    \node[main_node] (1) at (0,0) {};
    \node[main_node] (2) at (1, 0)  {};
    \node[main_node] (3) at (1, 1) {};
    \node[main_node] (4) at (0, 1) {};

    \draw (1) -- (2) -- (3) -- (4) -- (1);
\end{tikzpicture}
\end{center}

\end{example}

Mithilfe von kantenmaximalen Graphen können wir auch untere
Schranken beweisen, wie wir dies mit minimalen Graphen
in Satz \ref{thm:minDetLowerBound} getan haben. Hier ist
jedoch nicht die Anzahl der Kanten des Graphen ausschlaggebend,
sondern die Anzahl der \emph{fehlenden} Kanten.

\begin{Satz}[Kantenmaximaler Graph liefert untere Schranke]
\label{thm:EdgeMaxGraphLowerBound}
Sei $G\in \mathcal{G}_n$ ein kantenmaximaler Graph der monotonen
Graph-Eigenschaft $P_n \subseteq \mathcal{G}_n$.
Dann gilt für jeden deterministischen Algorithmus $\mathcal{A}$,
der $P_n$ entscheidet: 
$$ C(\mathcal{A}, G) \geq \binom{n}{2} - |E(G)| $$
\end{Satz}
\begin{proof}
Der Beweis erfolgt analog zu dem von Satz \ref{thm:minDetLowerBound},
wobei nun die Kanten, die nicht zum Graphen gehören, vom Algorithmus
abgefragt werden müssen.
\end{proof}
Wir erhalten nun analog zum Fall der minimalen Graphen eine untere
Schranke für die randomisierte Abfragekomplexität:
\begin{corollary} [Kantenmaximaler Graph liefert untere Schranke
für die randomisierte Abfragekomplexität]
\label{thm:EdgeMaximalRandCompl}
Sei $G\in\mathcal{G}_n$ ein kantenmaximaler Graph der monotonen
Graph-Eigenschaft $P_n \subseteq \mathcal{G}_n$.
Dann gilt
$$ C_R(P_n) \geq \binom{n}{2} - |E(H)| $$
\end{corollary}
\begin{proof}
Der Beweis erfolgt analog zum Beweis von Korollar \ref{cor:MinGraphRandCompl}
unter Verwendung von Satz \ref{thm:EdgeMaxGraphLowerBound}.
\end{proof}

\section{Konkrete Kriterien für untere Schranken}
Die bisher gezeigten unteren Schranken sind schwer auf konkrete
Fälle anzuwenden, da zuerst passende minimale Graphen oder kantenmaximale
Graphen gefunden werden müssen, die zu der Eigenschaft gehören.
In diesem Abschnitt entwickeln wir daher einige einfach zu überprüfende
Kriterien für Graph-Eigenschaften, aus denen dann eine gute
untere Schranke folgt. \\
Wir beschränken uns hierfür auf Eigenschaften, bei denen einer
der minimalen Graphen nur wenige Ecken mit positivem Grad hat
im Vergleich zur gesamten Eckenanzahl. Ein Beispiel dafür wäre
die Eigenschaft $\operatorname{P}_{100}(\{ \ \Square \ \})$,
denn hier hat der minimale Graph nur $4$ Ecken mit positivem
Grad, aber Eingaben haben $100$ Ecken. \\
Wir gehen folgendermaßen vor: Wir konstruieren für Eigenschaften,
die gewisse Kriterien erfüllen, kantenmaximale Graphen mit 
relativ wenigen Kanten. Mithilfe von Korrollar 
\ref{thm:EdgeMaximalRandCompl} erhalten wir so eine untere Schranke
für die randomisierte Abfragekomplexität. \\
Die Bezeichnung $V_{>0}(G)$ verwenden wir für die
Menge der Ecken mit positivem Grad des Graphen $G$.

\subsection{Konstruktion kantenmaximaler Graphen}
Die Hauptidee: Wir nehmen einen minimalen Graphen (der eine
relativ geringe Eckenanzahl hat) und wählen zwei benachbarte Ecken
$u$ und $v$. Wir konstruieren nun einen Graphen, indem wir aus dem
minimalen Graphen die Ecken $u$ und $v$ herauslöschen und dann eine große
Anzahl von Kopien von $u$ und $v$ hinzufügen, jedoch ohne die Kante
zwischen $u$ und $v$. Eine \emph{Kopie} einer Ecke $u$ ist hier
eine Ecke $u'$, die die gleiche Nachbarmenge wie $u$ hat, für
die also $N(u)=N(u')$ gilt.\\
Fügt man nun eine beliebige Kante zwischen einer Kopie von $u$ und einer
Kopie von $v$ ein, dann entsteht ein minimaler Graph. Wenn der
konstruierte Graph die Eigenschaft also nicht erfüllt, so sorgt 
ein Hinzufügen einer Kante dafür, dass die Eigenschaft erfüllt wird.
Folglich müssen alle diese entscheidenden Kanten abgefragt werden.
Da die Anzahl der in Frage kommenden Kanten groß ist, erhalten
wir eine gute untere Schranke für die Abfragekomplexität.
Fügt man alle Kanten hinzu, deren Ergänzung die Eigenschaft
nicht hervorruft, so erhält man sogar einen kantenmaximalen Graphen,
mit dem man dann mithilfe von Korollar \ref{thm:EdgeMaximalRandCompl}
direkt eine untere Schranke bekommt.
Im folgendem Beispiel führen wir diese Konstruktion einmal
exemplarisch durch.

% Hier Beispiel einfügen für die Konstruktion
\begin{example}[Konstruktion eines kantenmaximalen Graphen]
Wir betrachten die Graph-Eigenschaft $P_6(\{\Square\})$: ob der
Graph einen $4$-Kreis enthält.
Wir wählen nun zwei benachbarte Ecken $u$ und $v$ des minimalen
Graphen aus:
\begin{center}
\begin{tikzpicture}[main_node/.style={draw, circle, minimum size=0.8em,inner sep=2pt]}]

    \node[main_node] (1) at (0,0) {};
    \node[main_node] (2) at (1, 0)  {v};
    \node[main_node] (3) at (1, 1) {u};
    \node[main_node] (4) at (0, 1) {};

    \draw (1) -- (2) -- (3) -- (4) -- (1);
\end{tikzpicture}
\end{center}
Nun löschen wir die Kante zwischen $u$ und $v$ und fügen
in diesem Fall eine Kopie der Ecke $u$ und eine Kopie
der Ecke $v$ hinzu, sodass wir $6$ Ecken haben, da es 
sich um eine Eigenschaft auf $6$ Ecken handelt:
\begin{center}
\begin{tikzpicture}[main_node/.style={draw, circle, minimum size=1.5em,inner sep=2pt]}]

    \node[main_node] (1) at (0,0) {};
    \node[main_node] (2) at (2, -1)  {v};
    \node[main_node] (3) at (2, 3) {u};
    \node[main_node] (4) at (0, 2) {};
    
    \node[main_node] (5) at (3.5, 2) {u'};
    \node[main_node] (6) at (3.5, 0) {v'};

    \draw (1) -- (2); 
    \draw (3) -- (4) -- (1);
    \draw (5) -- (4);
    \draw (6) -- (1);
    \draw[dotted] (2) -- (3);
    \draw[dotted] (2) -- (5);
    \draw[dotted] (5) -- (6);
    \draw[dotted] (3) -- (6);
\end{tikzpicture}
\end{center}
Die Kanten, deren Hinzufügen einen Subgraphen \Square \ entstehen
lässt, werden hier gestrichelt dargestellt. Der konstruierte
Graph selbst enthält keinen solchen Subgraphen (Wie wir später
sehen werden, liegt dies daran, dass der minimale Graph regulär
ist). Um aus diesem konstruierten Graphen einen kantenmaximalen
Graphen zu machen, müssen nun noch Kanten hinzugefügt werden,
bis das Hinzufügen einer beliebigen, nicht zum Graphen gehörenden
Kante, einen Subgraphen entstehen lässt. Die Wahl der hinzugefügten
Kanten ist jedoch nicht eindeutig. Eine Möglichkeit ist
die folgende:
\begin{center}
\begin{tikzpicture}[main_node/.style={draw, circle, minimum size=1.5em,inner sep=2pt]}]

    \node[main_node] (1) at (0,0) {};
    \node[main_node] (2) at (2, -1)  {v};
    \node[main_node] (3) at (2, 3) {u};
    \node[main_node] (4) at (0, 2) {};
    
    \node[main_node] (5) at (3.5, 2) {u'};
    \node[main_node] (6) at (3.5, 0) {v'};

    \draw (1) -- (2); 
    \draw (3) -- (4) -- (1);
    \draw (5) -- (4);
    \draw (6) -- (1);
    
    \draw (2) -- (6);
    \draw (3) -- (5);
    
    \draw[dotted] (2) -- (3);
    \draw[dotted] (2) -- (5);
    \draw[dotted] (5) -- (6);
    \draw[dotted] (3) -- (6);
    
    % hinzugefügt gegenüber vorherigem Graphen.
    \draw[dotted] (5) -- (1);
    \draw[dotted] (6) -- (4);
\end{tikzpicture}
\end{center}
\end{example}

Die Konstruktion des Graphen formalisieren
wir nun:
\begin{definition}
[Duplizierungs-Graph $\Dupl(G, u, v, n)$]
Der Graph, der aus $G$ entsteht, indem man
die Kante zwischen $u\in V(G)$ und $v\in V(G)$ löscht
und dann $n\in \mathbb{N}$ Kopien von $u$ und $n$
Kopien von $v$ hinzufügt, bezeichnen wir mit
$\Dupl(G, u, v, n)$.
\end{definition}

Damit wir einen kantenmaximalen Graphen erhalten, darf
der konstruierte Duplizierungs-Graph keinen minimalen Graphen
als Subgraphen enthalten. Also darf das Hinzufügen
von Kopien von Ecken keinen neuen minimalen Graphen
als Subgraphen erzeugen. Dies formalisieren wir 
folgendermaßen:
\begin{definition}[Duplizierungs-invarianter Graph]
Ein Graph $G$ heißt \emph{duplizierungs-invariant},
wenn es zwei benachbarte Ecken $u,v\in G$ gibt, 
sodass der Duplizierungsgraph $\Dupl(G, u, v, n)$,
für alle Werte von $n\in \mathbb{N}$, den Graphen
$G$ nicht als Subgraphen enthält.
\end{definition}

Mithilfe dieses Kriteriums können wir nun eine
untere Schranke für die randomsierte Abfragkomplexität
einiger Subgraph-Isomorphie-Eigenschaften (also Eigenschaften,
die nur einen minimalen Graphen haben) beweisen:
\begin{Satz}
[Untere Schranke für bestimmte Subgraph-Isomorphie-Eigenschaften]
\label{thm:SubgraphIsomorphismLowerBound}
Sei $H\in \mathcal{G}_n$ ein duplizierungs-invarianter Graph
mit genau $p$ Ecken, die einen positiven Grad haben.
Dann gilt für die Subgraph-Isomorphie-Eigenschaft $P_n(\{H\})$:
$$ C_R(P_n(\{H\})) \geq 
\Big{ ( } \Big \lfloor  \frac{n-p}{2} \Big \rfloor \Big{)}^{2} \geq
\Big ( \frac{n-p-1}{2} \Big ) ^2 =
\frac{1}{4}n^2 - \frac{1}{2}n(p+1) + \frac{1}{4}(p+1)^2
$$
\end{Satz}
\begin{proof}
Da $H$ nach Voraussetzung duplizierungs-invariant ist und die 
Eigenschaft nur einen minimalen Graphen hat, gibt es
$u,v \in H$, sodass der Graph 
$G:= \Dupl(H, u, v, \big \lfloor \frac{n-p}{2} \big \rfloor)$
die Eigenschaft $P_n(\{H\})$ nicht erfüllt. \\
Ist $u'\in G$ eine Kopie von $u$ und $v' \in G$ eine Kopie von $v$,
so wird durch das Hinzufügen der Kante $u'v'$ als Subgraph ein
minimaler Graph erzeugt, da $H-u-v \subseteq G$ gilt und
$H \subseteq H-u-v + u' + v' + u'v'$. Da $G$ nach Konstruktion
jeweils $\big \lfloor \frac{n-p}{2} \big \rfloor$ Kopien von
$u$ und von $v$ hat, gibt es mindestens
$\Big{ ( } \Big \lfloor  \frac{n-p}{2} \Big \rfloor \Big{)}^{2}$
Kanten, deren Hinzufügen die Eigenschaft $P_n(\{H\})$ hervorruft.
Wir konstruieren nun also einen kantenmaximalen Graphen $G'$ aus
$G$, indem wir nach und nach Kanten zu $G$ hinzufügen, die die
Eigenschaft unerfüllt lassen, bis dies nicht mehr möglich ist.
Dieser Graph $G'$ hat nun eine Kantenanzahl von:
$$ |E(G')| \leq \binom{n}{2} - 
\Big ( \Big \lfloor  \frac{n-p}{2} \Big \rfloor \Big{)}^{2} $$
da alle Kanten zwischen Kopien von $u$ und $v$ nicht zu dem
kantenmaximalen Graphen gehören können. Wenden wir nun
Korollor \ref{thm:EdgeMaximalRandCompl} mit dem kantenmaximalen
Graphen $G'$ an, so erhalten wir unsere untere Schranke für
die Abfragekomplexität:
$$ C_R(P_n(\{H\})) \geq 
\Big (  \Big \lfloor  \frac{n-p}{2} \Big \rfloor \Big )^2$$
Da $\Big \lfloor  \frac{n-p}{2} \Big \rfloor \geq \frac{n-p-1}{2}$
gilt, erhalten wir dann durch Umformen:
$$ \Big ( \Big \lfloor  \frac{n-p}{2} \Big \rfloor \Big{)}^{2} \geq
\Big ( \frac{n-p-1}{2} \Big ) ^2 =
\frac{1}{4}(n-p-1)^2 =
\frac{1}{4}n^2 - \frac{1}{2}n(p+1) + \frac{1}{4}(p+1)^2
$$
\end{proof}

\begin{example}[Anwendung dieses Satzes]
Der Graph $K_4 =$
\begin{tikzpicture}[main_node/.style={circle,fill=black},
inner sep=1.5pt, baseline=2pt]

    \node[main_node] (1) at (0,0) {};
    \node[main_node] (2) at (0.35, 0)  {};
    \node[main_node] (3) at (0.35, 0.35) {};
    \node[main_node] (4) at (0, 0.35) {};

    \draw (1) -- (2) -- (3) -- (4) -- (1);
    \draw (4) -- (2);
    \draw (3) -- (1);
\end{tikzpicture} ist duplizierungs-invariant, da die Kopien
der Ecken jeweils nur Grad $2$ haben. Zudem
hat er $p=4$ Ecken mit positivem Grad. Für die Familie von
Eigenschaften $P_n(\{K_4\})$ mit $ n\geq 4$ erhalten wir also
mit Satz \ref{thm:SubgraphIsomorphismLowerBound} folgende
untere Schranke für die randomisierte Abfragekomplexität:
$$ C_R(P_n(\{K_4\})) \geq 
\Big ( \Big \lfloor  \frac{n-4}{2} \Big \rfloor \Big ) ^2 \geq
\Big ( \frac{n-5}{2} \Big ) ^2 = 
\frac{1}{4} n^2 - \frac{5}{2} n + \frac{25}{4} 
$$
Die gezeigte untere Schranke ist hier also nur um einen
konstanten Faktor von dem theoretischen Maximum
der randomisierten Abfragekomplexität
$\binom{n}{2} = \frac{1}{2}n^2 - \frac{1}{2}n - \frac{1}{2}$
entfernt.
\end{example}

\subsection{Kriterien für das Gelingen der Konstruktion}
Satz \ref{thm:SubgraphIsomorphismLowerBound}, der gute
untere Schranken für die randomisierte Abfragekomplexität
liefert, hat als Voraussetzung, dass der minimale Graph
\emph{duplizierungs-invariant} ist. Damit man den 
Satz möglichst direkt auf einen Fall anwenden kann, 
zeigen wir nun einige Kriterien dafür, wann ein
Graph duplizierungs-invariant ist.
\begin{Satz}[Hinreichende Kriterien für Duplizierungs-Invarianz]
\label{thm:KriterienDuplizierungsInvariant}
Ein Graph $H$ ist duplizierungs-invariant, wenn eines
der vorliegenden Kriterien erfüllt ist:
\begin{description}
\item[(a)] Es gibt eine Kante $uv\in H$, sodass sowohl
           der Grad von $u$ als auch der Grad von $v$
           minimal unter allen Ecken von $H$ mit positivem
           Grad ist.
\item[(b)] Es gibt eine Kante $uv \in H$ und eine Zahl
           $k\in \mathbb{N}$, sodass $u$ und $v$
           Teil einer $k$-Clique in $H$ sind, aber nicht
           in $H-uv$.
\end{description}
\end{Satz}
\begin{proof}
\hfill
\begin{description}
\item[(a)] Wir betrachten den Graphen $\Dupl(H,u,v,n)$ für ein
           beliebiges $n\in \mathbb{N}$ und
           nehmen o.B.d.A. an, dass $\deg(u) \geq \deg(v)$ in $H$
           gilt. \\
           Da der Grad von $u$ und $v$ minimal unter allen
           Ecken von $H$ mit positivem Grad ist, gibt es
           mindestens $|V_{>0}(H)| - 1$ Ecken mit Grad $\geq \deg(u)$,
           nämlich mindestens alle Ecken von $H$ mit positivem Grad
           außer $v$.
           Im Graph $\Dupl(H,u,v,n)$ gibt es jedoch nur 
           $|V_{>0}(H)|-2$ Ecken mit Grad $\geq \deg(u)$, da alle
           Kopien von $u$ und $v$ höchstens Grad $\deg(u)-1$ haben
           und die Kante zwischen $u$ und $v$ gelöscht wurde.
           Somit kann $H$ kein Subgraph von $\Dupl(H,u,v,n)$ sein.
\item[(b)] Wir betrachten wieder den Graphen $\Dupl(H,u,v,n)$ für
           ein beliebiges $n\in \mathbb{N}$. Sei nun $m\in \mathbb{N}$
           die Anzahl der $k$-Cliquen in $H$. Da $u$ und $v$ nicht
           Teil einer $k$-Clique in $H-u-v$ sind, sind auch alle
           Kopien von $u$ und $v$ nicht Teil einer $k$-Clique in
           $\Dupl(H,u,v,n)$. Somit gibt es in $\Dupl(H,u,v,n)$ 
           genau so viele $k$-Cliquen wie in $H-u-v$. Da $u$ und
           $v$ Teil einer $k$-Clique in $H$ sind, aber 
           nicht in $H-u-v$, ist die Anzahl der $k$-Cliquen in
           $H-u-v$ und damit in $\Dupl(H,u,v,n)$ höchstens $m-1$
           und daher kleiner als $m$. Folglich enthält $\Dupl(H,u,v,n)$
           nicht den Subgraphen $H$.
\end{description}
\end{proof}

Mithilfe dieser Kriterien erhalten wir nun
eine direkte untere Schranke für die randomisierte Abfragekomplexität:
\begin{corollary}[Konkrete untere Schranken für Subgraph-Isomorphie-Eigenschaften]
Sei $H$ ein Graph mit $p=|V_{>0}(H)|$ Ecken mit positivem Grad
und $n\in \mathbb{N}$. \\
Erfüllt $H$ eines der folgenden Kriterien:
\begin{description}
\item[(a)] Es gibt eine Kante $uv\in H$, sodass sowohl
           der Grad von $u$ als auch der Grad von $v$
           minimal unter allen Ecken von $H$ mit positivem
           Grad ist.
\item[(b)] Es gibt eine Kante $uv \in H$ und eine Zahl
           $k\in \mathbb{N}$, sodass $u$ und $v$
           Teil einer $k$-Clique in $H$ sind, aber nicht
           in $H-uv$.
\end{description}
so gilt für die randomisierte Abfragekomplexität der Eigenschaft 
$P_n(\{H\})$:
$$ C_R(P_n(\{H\})) \geq
\Big{ ( } \Big \lfloor  \frac{n-p}{2} \Big \rfloor \Big{)}^{2} \geq
\frac{1}{4}n^2 - \frac{1}{2}n(p+1) + \frac{1}{4}(p+1)^2
$$
\end{corollary}
\begin{proof}
Der Graph $H$ ist nach Satz \ref{thm:KriterienDuplizierungsInvariant}
duplizierungs-invariant. Es folgt somit mit 
Satz \ref{thm:SubgraphIsomorphismLowerBound} die entsprechende
untere Schranke für die randomisierte Abfragekomplexität.
\end{proof}

\begin{example}[Anwendungen des vorherigen Korollars]
Ist der Graph $H\in\mathcal{G}_n$ regulär, so haben
alle Ecken minimalen Grad. $H$ erfüllt also Kriterium (a)
von Satz \ref{thm:KriterienDuplizierungsInvariant}.
Die Eigenschaft $P_n(\{H\})$ hat also eine randomisierte
Abfragekomplexität von 
$$ C_R(P_n(\{H\})) \geq
\frac{1}{4}n^2 - \frac{1}{2}n(p+1) + \frac{1}{4}(p+1)^2$$
wobei $p=|V_{>0}(H)|$ die Anzahl der Ecken von $H$ mit
positivem Grad ist. \\
Ist nun $H=\Square$, so gilt für $n\geq 4$:
$$ C_R(P_n(\{\ \Square \ \})) \geq
\frac{1}{4}n^2 - \frac{5}{2}n + \frac{25}{4}$$
\end{example}

\subsection{Limitierungen dieses Ansatzes}
Im vorherigen Abschnitt haben wir gezeigt, dass viele Eigenschaften,
die einen  minimalen Graphen mit wenigen Ecken haben, einen kantenmaximalen
Graphen mit wenigen Kanten haben. Es stellt sich nun die Frage,
ob man dies so weit verallgemeinern kann, dass alle Eigenschaften
mit minimalen Graphen mit wenigen Kanten auch einen kantenmaximalen
Graphen mit wenigen Kanten haben. Daraus würde eine allgemeine
untere Schranke für die randomisierte Abfragekomplexität folgen.
Wir zeigen nun jedoch, dass dies nicht allgemein gilt, indem wir
eine Eigenschaft finden, die einen minimalen Graphen mit wenigen
Kanten hat und dennoch nur kantenmaximale Graphen mit vielen Kanten. \\
Dies ist folgende Familie von Eigenschaften:
$$ P'_n := \{ \ G \in \mathcal{G}_n \ 
| \ \exists u\in V(G) \textup{ mit } \deg(u) = n-1 \ \}$$
In Worten: Die Eigenschaft, dass es eine Ecke gibt,
die zu allen anderen Ecken eine Kante hat.
Die Eigenschaft $P'_n$ hat einen minimalen Graphen mit
$n-1$ Kanten. Die Anzahl der Kanten des minimalen Graphen
liefert also keine gute untere Schranke für die Abfragekomplexität.
Wir zeigen nun, dass alle kantenmaximalen Graphen von $P'_n$
eine sehr hohe Kantenanzahl haben. Also folgt auch aus der Kantenanzahl
der kantenmaximalen Graphen keine gute untere Schranke.
\begin{Satz}[Alle kantenmaximalen Graphen von $P'_n$ 
             haben eine hohe Kantenanzahl]
Sei $G\in \mathcal{G}_n$ ein beliebiger kantenmaximaler Graph
von $P'_n$ für ein $n\in \mathbb{N}$. Dann gilt
$$ |E(G)| \geq \binom{n}{2} - n $$
\end{Satz}
\begin{proof}
Sei $E' := (V \times V) \backslash E(G)$ die Menge der Kanten, die nicht
zu $G$ gehören. Da $G$ kantenmaximal ist, ruft das Hinzufügen
einer dieser Kanten immer die Eigenschaft $P'_n$ hervor.
Folglich muss jede Kante in $E'$ eine inzidente Ecke mit Grad
$n-2$ haben. Diese Ecken sind für verschiedene Kanten in $E'$
paarweise verschieden voneinander, denn ansonsten wäre der
Grad der Ecke höchstens $n-3$. Da $G$ genau $n$ Ecken hat,
erhalten wir durch Abzählen, dass $|E'| \leq n$ gilt.
Wir erhalten somit:
$$ E(G) = \binom{n}{2} - |E'| \geq \binom{n}{2} - n $$
\end{proof}

Mitttels Korollar \ref{thm:EdgeMaximalRandCompl} folgt also bestenfalls
eine untere Schranke von $C_R(P'_n) \geq n$. Somit können
wir mit unseren bisherigen Methoden keine gute untere Schranke
für diese Eigenschaft zeigen. Dafür müssen andere Methoden
entwickelt werden.

\chapter{Verallgemeinerung auf symmetrische Eigenschaften}
In diesem Kapitel verallgemeinern wir das Konzept der
Graph-Eigenschaft auf Eigenschaften von Bitfolgen, die
symmetrisch sind, d.h. invariant gegenüber einer Symmetriegruppe.
Danach beschäftigen wir uns mit der Abfragekomplexität
solcher Eigenschaften. \\
Eine Bitfolge stellen wir hier als Element eines Vektorraums
über den endlichen Körper $\mathbb{F}_2$ der Ordnung $2$ dar.
Für die Bitfolge ``101`` würden wir also schreiben:
$ (1,0,1) \in \mathbb{F}_2^3$.

\section{Allgemeine symmetrische Eigenschaften}
Um die Symmetrie zu formalisieren, müssen wir zunächst
eine spezielle Gruppenoperation definieren:

\begin{definition}
[Operation der symmetrischen Gruppe $\mathbb{S}_m$ auf $\mathbb{F}_2^m$]
Die Gruppenoperation
$$\mathbb{S}_m \times \mathbb{F}_2^m \to \mathbb{F}_2^m, \ (\sigma,g) \mapsto \sigma(g)$$
ist so definiert, dass für alle Indizes $1\leq i \leq m$ gilt:
$$ \sigma(g)_i = g_{\sigma(i)} $$
\end{definition}
Die symmetrische Gruppe permutiert also die Komponenten eines
Vektors. Eine Eigenschaft ist nun symmetrisch, wenn sie invariant
gegenüber dieser Gruppenoperation ist:
\footnote{vgl. \cite[S.7]{Rivest}}

\begin{definition}[Symmetrische Eigenschaft]
Sei $m\in \mathbb{N}$ eine natürliche Zahl und
$S \leq \mathbb{S}_m$ eine Untergruppe der 
symmetrischen Gruppe vom Grad $m$. \\
Eine Teilmenge
$P_m \subseteq \mathbb{F}_2^m$ aller Bitfolgen der
Länge $m$ heißt \emph{$S$-symmetrische Eigenschaft}, wenn
für alle $\sigma \in S$ und alle $g\in \mathbb{F}_2^m$ gilt:
$$ \sigma(g)\in P_m \iff g \in P_m $$ 
\end{definition}

Eine Graph-Eigenschaft kann man als symmetrische
Eigenschaft auffassen. Hierbei ist $S$ die Gruppe
der Graph-Isomorphismen.
Analog zu Graph-Eigenschaften definiert man
\emph{monotone} symmetrische Eigenschaften.

\section{Abfragekomplexität symmetrischer Eigenschaften}
Wir betrachten nun einige Fälle für die Symmetriegruppe
$S$.
\begin{example}[$S$ ist die symmetrische Gruppe]
Sei $m\in \mathbb{N}$ beliebig.
Wir betrachten den Fall, dass $S=\mathbb{S}_m$
die symmetrische Gruppe ist. Ist nun 
$P_m\subseteq \mathbb{F}_2^m$ eine monotone 
$S$-symmetrische Eigenschaft, so muss 
$P_m$ von der Form 
$$ P_m= \{ g\in \mathbb{F}_2^m \ |
\ g \textup{ hat mindestens } k\textup{-mal die Komponente } 1 \ \}$$
sein, denn erfüllt $g\in \mathbb{F}_2^m$ die Eigenschaft
$P_,$, so muss dies auch für alle $g'=\sigma(g)\in\mathbb{F}_2^m$
mit $\sigma\in S$ gelten. Da $S=\mathbb{S}_m$ alle Permutationen
umfasst, sind für $g'\in P_m$ alle Vektoren mit
genau so vielen Komponenten mit Wert $1$ wie $g$ möglich. Aus der
Monotonie von $P_m$ folgt dann, dass alle Vektoren mit
mindestens dieser Anzahl an Komponenten mit Wert $1$ zu
$P_m$ gehören. \\
Alle $S$-symmetrischen Eigenschaften 
$P_m \subseteq \mathbb{F}_2^m$haben eine Abfragekomplexität
von $C_R(P_m) = m$.
\begin{proof}
Wie oben gezeigt, ist $P_m$ von der Form
$$ P_m= \{ g\in \mathbb{F}_2^m \ |
\ g \textup{ hat mindestens } k\textup{-mal die Komponente } 1 \ \}$$
für ein $k\in \mathbb{N}$
Wir betrachten für $m\in\mathbb{N}$ den Input (in String-Schreibweise)
$g=1^{k-1}0^{m-k+1}\in \mathbb{F}_2^m$. 
\end{proof}
\end{example}

\section{Algebraische Formulierungen}
Dem aufmerksamen Leser ist schon aufgefallen, dass die in 
Abschnitt \ref{sec:queryComplexity} getroffenen Definitionen
zur Abfragekomplexität relativ schwammig ausgefallen sind.
Dies macht es schwierig, die entsprechenden Definitionen
für mathematische Beweise zu verwenden.
Dies wollen wir nun beheben, indem wir eine komplett algebraisch
formulierte Definition für die Abfragekomplexität angeben.
Dadurch sind wir in der Lage, algebraische Methoden zu verwenden.
% Verschiedene Möglichkeiten, Algorithmen / Abfragekomplexität
% algebraisch zu charakterisieren.


\section{Algebraische Ansätze}
% Gruppenoperationen etc.


\printbibliography
\end{document}
