\documentclass[10pt,a4paper, footheight=1mm, bibliography=totoc]{scrreprt}
\usepackage[utf8]{inputenc}
\usepackage[ngerman]{babel}
\usepackage{amsmath}
\usepackage{amsthm}
\usepackage[backend=biber,style=authortitle]{biblatex}
\usepackage[babel]{csquotes}
\usepackage{tikz}
\usepackage{amsfonts}
\usepackage{hyperref}
\usepackage{geometry}
\usepackage{framed}
\usepackage{needspace}
\usepackage{enumitem}
\usepackage{microtype}
\usepackage{etoolbox}
\usepackage{enumitem}
\usepackage{titlesec}
\geometry{
bottom=20mm,
top=20mm,
left=22mm,
right=22mm
}

\newtoggle{book}
%\toggletrue{book}
\togglefalse{book}

\setlist[description]{labelindent=\parindent}

\newtheorem{definition}{Definition}
\newtheorem{Satz}[definition]{Satz}
\newtheorem{conjecture}[definition]{Vermutung}
\newtheorem{corollary}[definition]{Korollar}
\newtheorem{Lemma}[definition]{Lemma}
\newtheorem{Proposition}[definition]{Proposition}
\theoremstyle{definition}
\newtheorem{examplex}{Beispiel}

\newenvironment{example}[1]
{ \begin{leftbar} \begin{examplex}#1}
{ \end{examplex} \ignorespacesafterend \end{leftbar} }

\addbibresource{literature.bib}

\renewcommand{\footnoterule}{%
  \kern -3pt
  \hrule width \textwidth height 1pt
  \kern 2pt
}

% Freiraum vor Kapitelanfang entfernen
\renewcommand*{\chapterheadstartvskip}{\vspace*{-\baselineskip}}

% Mehr Freiraum vor Abschnitts-Überschriften
\titlespacing{\section}{0pt}{0.8cm}{0.25cm}
%\titlespacing{\chapter}{0pt}{0.8cm}{-0.2cm}


\DeclareMathOperator\Min{Min}
\DeclareMathOperator\Dupl{Dupl}
\DeclareMathOperator*\argmin{arg\,min}
\DeclareMathOperator\Hom{Hom}

\newcommand{\Square}{
\begin{tikzpicture}[main_node/.style={circle,fill=black},
inner sep=1.5pt, baseline=2pt]

    \node[main_node] (1) at (0,0) {};
    \node[main_node] (2) at (0.35, 0)  {};
    \node[main_node] (3) at (0.35, 0.35) {};
    \node[main_node] (4) at (0, 0.35) {};

    \draw (1) -- (2) -- (3) -- (4) -- (1);
\end{tikzpicture}
}

% \title{Untere Schranken für die Abfragekomplexität 
%       monotoner symmetrischer Eigenschaften}
% \subtitle{Facharbeit im Fach Informatik}
% \author{Autor: Erik Diessel}

% \date{Abgabetermin: 20. April 2015}

\begin{document}


\iftoggle{book}
{ 
    \newpage
    \thispagestyle{empty}
    \mbox{}
    \addtocounter{page}{-1}
    \newpage
    \thispagestyle{empty}
    \mbox{}
    \addtocounter{page}{-1}
    \newpage
    \thispagestyle{empty}
    \mbox{}
    \addtocounter{page}{-1}
    \newpage
    \thispagestyle{empty}
    \mbox{}
    \addtocounter{page}{-1}
}{}

% \maketitle

\input{titlepage}

\addtocounter{page}{-1}

\begin{large}
\tableofcontents
\end{large}

\addtocounter{page}{-1}

\thispagestyle{empty}

\chapter{Einleitung}
Die Frage, welche Komplexität ein Problem hat, d.h.
wie viele Ressourcen ein Algorithmus benötigt,
um ein Problem zu lösen, ist eine der dominierenden
Fragestellungen der theoretischen Informatik.
Der bekannteste Fall ist hier die Frage, ob die beiden
Komplexitätsklassen $P$ und $NP$ identisch sind. Diese
Frage dreht sich um die Zeitkomplexität, die bestimmte
Probleme benötigen. Die Komplexität eines Problems zu ermitteln, hat
große Relevanz für die Praxis, da dies die theoretischen
Grenzen für die Performance eines Algorithmus aufzeigt.

Um die vermutete Ungleichheit $P\neq NP$ zu zeigen,
muss eine untere Schranke für die Komplexität einiger
Probleme gezeigt werden. Bis heute scheint dies jedoch
in weiter Ferne.\footnote{vgl. \cite{PvsNP}}
In dieser Facharbeit beschäftigen wir uns daher mit
der  Abfragekomplexität von Eigenschaften. 
Dies ist die Anzahl an Abfragen, die bezüglich 
einzelner Kanten bzw. einzelner Bits gestellt werden
müssen, um zu entscheiden, ob ein Graph bzw. eine
Bitfolge eine gegebene Eigenschaft erfüllt.
Im Gegensatz
zur Zeitkomplexität ist es hier möglich, gute
untere Schranken zu beweisen. Die Entwicklung
neuer Methoden für untere Schranken bei diesem "`einfachen"' Fall
führt dann eventuell zu neuen Impulsen für untere
Schranken bei der Zeitkomplexität.

Im Kontext von ungerichteten Graphen
ist die Abfragekomplexität die Anzahl
an Abfragen der Form "`Besteht eine Kante zwischen
der Ecke $u$ und der Ecke $v$ ?"', die ein Algorithmus
benötigt, um zu entscheiden, ob ein gegebener Graph
eine Eigenschaft erfüllt. Eine Graph-Eigenschaft ist
dabei unabhängig von der konkreten Benennung der Ecken.

Von Rivest und Vuillemin wurde gezeigt,
dass die Abfragekomplexität
im Fall von monotonen Graph-Eigenschaften, die beim 
Hinzufügen von Kanten erhalten bleiben, asymptotisch
quadratisch in der Anzahl der Knoten
ist\footnote{siehe: \cite[Theorem 6]{Rivest}}: $C(P_n) \geq \frac{1}{16}n^2$.
Die Aanderaa-Karp-Rosenberg-Vermutung, dass im Worst-Case
zum Entscheiden einer monotonen Graph-Eigenschaft
alle Kanten abgefragt werden müssen, d.h. dass
$C(P_n)=\binom{n}{2}$ gilt, ist jedoch schon
seit Jahrzehnten offen. Mit dieser Facharbeit
wollen wir nun an der Weiterentwicklung von Methoden
für das Beweisen unterer
Schranken für die Abfragekomplexität
von Eigenschaften mitwirken, damit ein Beweis dieser Vermutung
weiter in die Nähe rückt.

Diese Arbeit ist folgendermaßen aufgebaut:
Wir definieren zunächst die Abfragekomplexität
von Graph-Eigenschaften im deterministischem und
randomisiertem Fall. Nachdem wir die Konzepte
"`minimaler Graph"' und "`kantenmaximaler Graph"'
eingeführt haben, zeigen wir einige untere Schranken
für die Abfragekomplexität, die auf diesen Begriffen
basieren. Im nächsten Kapitel zeigen wir dann einige
konkretere untere Schranken für eine Vielzahl von
Graph-Eigenschaften. Nachdem wir die Grenzen 
dieses Ansatzes ausgeleuchtet haben, verallgemeinern
wir das Konzept der Graph-Eigenschaften auf 
symmetrische Eigenschaften von Bitfolgen. Für
diese Fälle zeigen wir einige untere Schranken.
Danach formulieren wir die Begriffe "`Algorithmus"'
und "`Abfragekomplexität"' noch einmal algebraisch, um
in einem letzten Abschnitt
einige algebraische Ansätze für Methoden vorstellen zu
können, die noch bessere untere Schranken ermöglichen könnten.

\chapter{Die Abfragekomplexität von monotonen Graph-Eigenschaften}
\section{Grundlegende Definitionen}
\subsection{Graph-Eigenschaften}
Im graphentheoretischen Teil folgen wir größtenteils
der Notation eines Standardwerkes der Graphentheorie\footnote{\cite{diestel}}.

Mit $\mathcal{G}_n$ bezeichnen wir die Menge aller
(ungerichteten) Graphen mit $n$ Ecken.
Den vollständigen Graphen auf $n$ Ecken bezeichnen wir
mit $K_n$.
Ist $G \in \mathcal{G}_n$ ein Subgraph von $G' \in \mathcal{G}_n$,
so schreiben wir $G \subseteq G'$. Wenn $G$ ein
echter Subgraph von $G'$ ist, d.h. wenn auch $E(G) \neq E(G')$ gilt, schreiben
wir $G \subset G'$ oder $G' \supset G$.
Für $G' = (V, E \cup \{e\})$ schreiben wir vereinfachend
$G' = G + e$ und für 
$G' = \big(V \backslash \{v\}, E\cap(V \backslash \{v\})\times (V \backslash \{v\})\big)$ vereinfachend $G' = G - v$.


\begin{definition}[Graph-Eigenschaft]
Eine Teilmenge $P_n \subseteq \mathcal{G}_n$ der Graphen mit
$n$ Ecken heißt \emph{Graph-Eigenschaft auf $n$ Ecken},
wenn sie invariant unter Graph-Isomorphie ist,
d.h. wenn für je zwei isomorphe Graphen $G, G'$ gilt:
$G \in P \iff G' \in P$.
\end{definition}
Statt $G \in P_n$ sagen wir auch: $G$ erfüllt die Eigenschaft $P_n$.


\begin{definition}[Monotone Graph-Eigenschaft]
Eine Graph-Eigenschaft $P_n$ heißt \emph{monoton}, wenn das
Hinzufügen von Kanten die Eigenschaft erhält,
d.h. wenn ein Graph
$G' \in \mathcal{G}_n$ ein Supergraph von
$G \in \mathcal{G}_n$ ist, so gilt 
$G \in P_n \implies G' \in P_n$.
\end{definition}

\begin{example}[Monotone Graph-Eigenschaft]
\label{exmpl:Monotonie}
Wir betrachten die folgende Graph-Eigenschaft 
$P_4 \subseteq \mathcal{G}_4$ auf $4$ Ecken:
$$P_4 := \{ G \in \mathcal{G}_4 \ | \ G \text{ enthält den Subgraphen } K_3 \}$$
Diese Eigenschaft ist \emph{monoton}, da wenn 
$G \in P_4$ gilt, $G$ den Subgraphen $K_3$
enthält, woraus folgt, dass auch jeder Supergraph $G'\supseteq G$
den Subgraphen $K_3$ enthält. 
\end{example}

Im Folgenden werden wir uns auf monotone Graph-Eigenschaften beschränken.
Um einige degenerierte Fälle auszuschließen, beschränken
wir uns auch auf \emph{nichttriviale} Eigenschaften.
\begin{definition}[Nichttriviale Graph-Eigenschaft]
Eine monotone Graph-Eigenschaft $P_n$ heißt \emph{nichttrivial},
wenn der leere Graph $E_n$ nicht in $P_n$ enthalten ist und
$P_n\neq \emptyset$ gilt.
\end{definition}
Die Bedingung $E_n \notin P_n$ bedeutet, dass $P_n$ nicht
alle Graphen auf $n$ Ecken beinhaltet. In diesem Fall würde
es keinen Sinn machen, mit einem Algorithmus zu berechnen,
ob ein gegebener Graph die Eigenschaft erfüllt, da das Ergebnis
unabhängig vom Graphen wäre.

\begin{definition}[Minimaler Graph]
Ein Graph $G \in \mathcal{G}_n$ heißt
\emph{minimaler Graph der montonen Graph-Eigenschaft $P_n$},
wenn $G \in P_n$ gilt, aber jeder echte Subgraph 
$G' \subset G$ die Eigenschaft $P_n$ nicht erfüllt.
\end{definition}

In Beispiel \ref{exmpl:Monotonie} ist
\begin{center}
\begin{tikzpicture}[main_node/.style={circle,fill=black,minimum size=0.8em,inner sep=2pt]}]

    \node[main_node] (1) at (0,0) {};
    \node[main_node] (2) at (-0.5, -0.75)  {};
    \node[main_node] (3) at (0.5, -0.75) {};
    \node[main_node] (4) at (1.2, -0.3) {};

    \draw (1) -- (2) -- (3) -- (1);
\end{tikzpicture}
\end{center}

der bis auf Isomorphie eindeutige \emph{minimale} 
Graph von $P_4$, da das Entfernen einer Kante
den Subgraphen $K_3$ zerstören würde.

\begin{definition}[Minimale Graphenmenge $\Min(P_n)$]
Die Menge der minimalen Graphen der monotonen Graph-Eigenschaft
$P_n$ heißt
$$\Min(P_n) := \{ G\in P_n \ | \ G \textup{ ist minimaler Graph von } P_n\}\,.$$
\end{definition}

Die Menge $\Min(P_n)$ charakterisiert die
Eigenschaft vollständig, wie folgender Satz zeigt:

\begin{Satz}[$\Min(P_n)$ legt $P_n$ eindeutig fest]
Sind $P_n, P'_n \subseteq \mathcal{G}_n$ zwei monotone 
Graph-Eigenschaften, so gilt
$\Min(P_n) = \Min(P'_n)$ genau dann, wenn $P_n = P'_n$.
\end{Satz}
\begin{proof} \hfill
\vspace*{-3mm}
\begin{description}
\item[$\boldsymbol{\Min(P_n) = \Min(P'_n) \implies P_n = P'_n}$]
\hfill \\
Sei $G \in P_n$ beliebig. Wir zeigen dann, dass auch $G \in P'_n$
gilt. Aus Symmetriegründen folgt dann, dass für einen  beliebigen
Graphen $G' \in P'_n$ gilt: $G' \in P_n$, woraus die Gleichheit der
Eigenschaften $P_n = P'_n$ folgt.

Wir setzen $G_0 := G$. Solange es möglich ist, wählen wir nun
eine Kante $e \in E(G_i)$, sodass für $G_{i+1} := G_i - e$  
weiterhin $G_{i+1} \in P_n$ gilt.
Es gibt nun ein $k$, für das es nicht mehr möglich ist,
aus $G_k$ eine Kante zu entfernen und dabei die Eigenschaft
zu erhalten (spätestens, wenn $G_k$ leer ist).
Der Graph $G_k$ ist dann per Konstruktion ein minimaler
Graph, folglich gilt $G_k \in \Min(P_n)$. Aufgrund der
Voraussetzung $\Min(P_n) = \Min(P'_n)$ gilt auch 
$G_k \in \Min(P'_n)$. Da die Eigenschaft $P'_n$ monoton ist,
und $G_j \subseteq G$, gilt dann auch $G_k \in P'_n$,
wie gefordert.
\vspace*{-2mm}
\item[$\boldsymbol{P_n = P'_n \implies \Min(P_n) = \Min(P'_n)}$]
\hfill \\
Wegen $P_n = P'_n$ ist $G \in \mathcal{G}_n$ offensichtlich
genau dann ein minimaler Graph von $P_n$, wenn $G$ ein 
minimaler Graph von $P'_n$ ist. Daraus folgt 
$\Min(P_n) = \Min(P'_n)$. \qedhere
\end{description}
\end{proof}
Der vorherige Satz ermöglicht uns, eine
monotone Eigenschaft einfacher zu beschreiben. 
Für die monotone Graph-Eigenschaft $P_n\subseteq \mathcal{G}_n$
mit der Menge an minimalen Graphen $\mathcal{H} = \Min(P_n)$
schreiben wir $\operatorname{P}_n(\mathcal{H})$. Die Eindeutigkeit dieser
Schreibweise folgt aus dem vorherigen Satz. \\
Dies macht das Formulieren von Eigenschaften sehr viel einfacher:
Die Eigenschaft aus Beispiel \ref{exmpl:Monotonie} lässt sich
so schreiben als $\operatorname{P}_4(\{K_3\})$.


\subsection{Abfragekomplexität}
\label{sec:queryComplexity}

Wir führen nun die ersten algorithmischen Begriffe ein.\footnote{vgl. \cite[S.7]{Rivest}}\\
Da wir uns nur mit der Abfragekomplexität beschäftigen,
vereinfachen wir unser Berechnungsmodell: \\
Einen Algorithmus stellen wir als Entscheidungsbaum dar.
Die Knoten sind hierbei mit einer Kante bezeichnet, die
abgefragt wird. Jeder Knoten hat zwei Kanten, die mit
"`ja"' und "`nein"' beschriftet sind, dies steht für
die Antwort auf die Abfrage. Die Blatt-Knoten sind
zusätzlich mit "`ja"' und "`nein"' beschriftet,
dies steht für den Rückgabewert des Algorithmus.
Zu beachten ist, dass der Algorithmus nur für eine
Eingabegröße, das heißt für eine Eckenanzahl $n$,
festgelegt ist.\\
Wir sagen nun, dass ein Algorithmus $\mathcal{A}$
die Graph-Eigenschaft $P_n$ \emph{entscheidet}, wenn
für jeden Input $G \in \mathcal{G}_n$ der Blatt-Knoten
des zugehörigen Pfades des Entscheidungsbaums genau
dann mit "`ja"' beschriftet ist, wenn $G \in P_n$ gilt.

\begin{example}[Entscheidungsbaum] \needspace{3 \baselineskip} \
\label{exmpl:decisionTree}
\begin{center}
\begin{tikzpicture} [
    level 1/.style = {sibling distance=7cm},
    level 2/.style = {sibling distance=3cm}, 
    level 3/.style = {sibling distance=2cm},
    font=\sffamily
]
\tikzstyle{every node}=[draw]

\node [draw] {$(1,2)\in G\,?$}
  child {  node {$(1,3)\in G\,?$} 
    child { node {$G \in P_3$} edge from parent node[left,draw=none] {ja} }
    child { node {$(2,3)\in G\,?$}
      child { node {$G \in P_3$} edge from parent node[left,draw=none] {ja} }
      child { node {$G \notin P_3$} edge from parent node[right,draw=none] {nein} }
      edge from parent node[right,draw=none] {nein} 
    }
    edge from parent node[left,draw=none,align=center] {ja\\}
  }
  child { node {$(2,3)\in G\,?$}
    child { node {$(1,3)\in G\,?$}
      child { node{$G \in P_3$} edge from parent node[left,draw=none] {ja} }
      child { node{$G \notin P_3$} edge from parent node[right,draw=none] {nein} }
      edge from parent node[left,draw=none] {ja}
    }
    child { node {$G \notin P_3$} edge from parent node[right,draw=none] {nein} }
    edge from parent node[right,draw=none,align=center] {nein\\} 
  };
\end{tikzpicture}
\end{center}
Der hier dargestellte Entscheidungsbaum entscheidet
die monotone Graph-Eigenschaft 
${P_3 := \big\{ G \in \mathcal{G}_n \ \big| \ |E(G)| \geq 2 \big\}}$,
d.h. ob der Graph mindestens $2$ Kanten hat.
Man sieht, dass die Anzahl an Abfragen von
dem Input abhängt.
\end{example}

Wir können nun unseren zentralen Begriff definieren.

\begin{definition}[Deterministische Abfragekomplexität]
Die \emph{Abfragekomplexität} $C(\mathcal{A},G)$ eines
Algorithmus $\mathcal{A}$ für den Input $G\in \mathcal{G}_n$ ist
die Länge des zu $G$ gehörenden Pfades des
Entscheidungsbaumes. \\
Die \emph{Abfragekomplexität} $C(\mathcal{A})$ eines
Algorithmus $\mathcal{A}$ ist dann
$$ C(\mathcal{A}) := \max_{G \in \mathcal{G}_n} C(\mathcal{A},G).$$
Die \emph{Abfragekomplexität} $C(P_n)$ einer Graph-Eigenschaft
$P_n\subseteq \mathcal{G}_n$ ist nun
$$ C(P_n) := \min_{\mathcal{A} \ {\rm entscheidet}\  P_n} C(\mathcal{A}).$$
\end{definition}

Der in Beispiel \ref{exmpl:decisionTree} dargestellte
Algorithmus hat eine Abfragekomplexität von $3$, da
der längste Pfad die Länge $3$ hat. \\
Die Aanderaa-Karp-Rosenberg-Vermutung lautet nun:\footnote{vgl. \cite[S.9]{Lovasz}}
\begin{conjecture}[Aanderaa-Karp-Rosenberg]
Jede monotone nichttriviale Graph-Eigenschaft $P_n$
hat eine Abfragekomplexität von
$$C(P_n) = \frac{n(n-1)}{2}$$
\end{conjecture}
Die Aanderaa-Karp-Rosenberg-Vermutung sagt also aus,
das bei allen monotonen Graph-Eigenschaften im Worst-Case
alle Kanten abgefragt werden müssen (denn ein Graph mit
$n$ Ecken hat genau ${\binom{n}{2}=\frac{n(n-1)}{2}}$ Kanten).

\subsection{Randomisierte Abfragekomplexität}

Bisher haben wir uns nur mit \emph{deterministischer}
Abfragekomplexität beschäftigt, d.h. die betrachteten
Algorithmen hatten keinen Zufall zur Verfügung.
Da randomisierte Algorithmen deterministischen Algorithmen
oft überlegen sind, müssen wir diese auch auf
die Abfragekomplexität hin untersuchen.
% Vielleicht Zitat einfügen für
% Problem, bei dem randomisierte Algorithmen klar
% überlegen sind.
Wir definieren hierfür zunächst randomisierte Algorithmen,
um dann deren Komplexität zu definieren\footnote{vgl.
\cite[S.120]{Groeger}}.
\begin{definition}[Randomisierter Algorithmus]
Ein \emph{randomisierter Algorithmus}, der eine
Eigenschaft $P_n$ entscheidet, ist eine
Wahrscheinlichkeitsverteilung von deterministischen
Algorithmen, die $P_n$ entscheiden. \\
Formal: eine Abbildung
$$ p_\textup{Alg}: \{ \mathcal{A} \ \textup {deterministisch} \ | \
         \mathcal{A} \ {\rm entscheidet} \ P_n \} \to \mathbb{R} $$
mit 
$$\sum_\mathcal{A} p_\textup{Alg}(\mathcal{A}) = 1.$$
\end{definition}

Das Ausführen eines randomisierten Algorithmus findet
dann so statt: Zu Beginn wird, mit den entsprechenden
Wahrscheinlichkeiten, ein deterministischer Algorithmus
ausgewählt, der dann ausgeführt wird.
Die randomisierte Abfragekomplexität ist dann der
Erwartungswert für die benötigte Anzahl an Abfragen.

\begin{definition}[Randomisierte Abfragekomplexität für einen Input]
\label{def:randComplInput}
Die \emph{randomisierte Abfragekomplexität} $C_R(P_n)$ eines randomisierten
Algorithmus $p_\textup{Alg}$, für den Input $G\in \mathcal{G}_n$, ist:
$$ C_R(p_\textup{Alg}, G) := 
\sum_\mathcal{A} p_\textup{Alg}(\mathcal{A}) \cdot C(\mathcal{A}, G)\,.$$
\end{definition}
Analog definieren wir nun die randomisierte Abfragekomplexität
eines Algorithmus:
\begin{definition}[Randomisierte Abfragekomplexität eines Algorithmus]
Die \emph{randomisierte Abfragekomplexität} eines randomisierten
Algorithmus $p_\textup{Alg}$ ist:
$$ C_R(p_\textup{Alg}) := \max_{G\in\mathcal{G}_n} C_R(p_\textup{Alg}, G)\,.$$
\end{definition}
Analog zum deterministischen Fall können wir nun die
\emph{randomisierte} Abfragekomplexität einer Graph-Eigenschaft
definieren:
\begin{definition}[Randomisierte Abfragekomplexität einer Graph-Eigenschaft]
\label{def:randComplProp}
Die \emph{randomisierte Abfragekomplexität} einer Graph-Eigenschaft
$P_n$ ist:
$$ C_R(P_n) := \min_{p_\textup{Alg}}\ C(p_\textup{Alg})\,,$$
wobei $p_\textup{Alg}$ aus allen randomisierten Algorithmen,
die $P_n$ entscheiden, gewählt wird.
\end{definition}

\section{Untere Schranken für die Abfragekomplexität}

\subsection{... anhand eines minimalen Graphen}

Wir zeigen nun einige einfache untere Schranken
für die Abfragekomplexität, die auf minimalen
Graphen basieren. Diese Aussagen ermöglichen uns
später, konkretere untere Schranken zu beweisen.\footnote{
Ein ähnlicher Ansatz wird verfolgt in: \cite{Groeger}}
\begin{Satz}[Größe des minimalen Graphen ist untere Schranke]
\label{thm:minDetLowerBound}
Sei $H\in \mathcal{G}_n$ ein minimaler Graph der monotonen
Graph-Eigenschaft $P_n$. Dann gilt für jeden deterministischen
Algorithmus $\mathcal{A}$, der $P_n$ entscheidet:
$$ C(\mathcal{A},H) \geq |E(H)|\,.$$
\end{Satz}
\begin{proof}
Wir führen einen Widerspruchsbeweis.

Angenommen $ C(\mathcal{A},H) < |E(H)| $.
Dann gibt es eine Kante $e\in H$,
die von $\mathcal{A}$ nicht abgefragt wird. Entfernen wir
diese Kante, so erhalten wir den Graphen $H' = H - e$, der,
da $H$ ein minimaler Graph ist, die Eigenschaft $P$ nicht
erfüllt. Der Algorithmus $\mathcal{A}$ gibt jedoch für $H$ und $H'$ das gleiche
Ergebnis zurück, da die sie unterscheidende Kante von $\mathcal{A}$
nicht abgefragt wird. Folglich entscheidet $\mathcal{A}$ die
Eigenschaft $P_n$ nicht korrekt. Dies ist ein Widerspruch zur
Voraussetzung. Folglich muss $ C(\mathcal{A,H}) \geq |E(H)| $ gelten. 
\end{proof}
Der Satz sagt nicht nur aus, dass die Abfragekomplexität
der Eigenschaft von unten beschränkt ist, sondern auch, dass
es einen bestimmten Input gibt, für den eine bestimmte Anzahl
an Abfragen benötigt werden, unabhängig davon, welchen Algorithmus
wir wählen. Dies bedeutet, dass ein randomisierter Algorithmus
auch diese Anzahl an Abfragen benötigt:
\begin{corollary}[Minimaler Graph liefert untere Schranke für 
                  randomisierte Abfragekomplexität]
\label{cor:MinGraphRandCompl}
Sei $H\in \mathcal{G}_n$ ein minimaler Graph der monotonen
Graph-Eigenschaft $P_n$. Dann gilt:
$$C_R(P_n) \geq |E(H)|\,.$$
\end{corollary}
\begin{proof}
Sei $p_\textup{Alg}$ ein beliebiger randomisierter Algorithmus,
der $P_n$ entscheidet.
Nach Definition \ref{def:randComplInput} gilt: 
$$ C_R(p_\textup{Alg}, H) = 
\sum_\mathcal{A} p_\textup{Alg}(\mathcal{A}) \cdot C(\mathcal{A}, H)\,.$$
Wegen Satz \ref{thm:minDetLowerBound} gilt $C(\mathcal{A}, H) \geq |E(H)|$
für alle deterministischen Algorithmen $\mathcal{A}$. Einsetzen ergibt:
$$ C_R(p_\textup{Alg}, H) \overset{\textup{Def. } \ref{def:randComplInput}} {=}
\sum_\mathcal{A} p_\textup{Alg}(\mathcal{A}) \cdot C(\mathcal{A}, H) 
\overset{\textup{Satz } \ref{thm:minDetLowerBound}} {\geq}
\sum_\mathcal{A} p_\textup{Alg}(\mathcal{A}) \cdot |E(H)| =
|E(H)| $$
Mit Definition \ref{def:randComplProp} erhalten wir dann
\begin{equation*}
C_R(P_n) \overset{\textup{Def. } \ref{def:randComplProp}} {=} 
\min_{p_\textup{Alg}}\ C(p_\textup{Alg}) \geq |E(H)|\,. \qedhere
\end{equation*}
\end{proof}

Wie man sieht, kann man mit minimalen Graphen einfach untere Schranken
für die Abfragekomplexität zeigen. Die Anzahl an Kanten $|E(H)|$
kann jedoch klein sein, sodass die untere Schranke weit vom tatsächlichen
Wert der Abfragekomplexität entfernt ist.
Im folgenden Abschnitt betrachten wir daher ein anderes Konzept.

\subsection{... anhand eines kantenmaximalen Graphen}

Wir führen daher nun das Konzept des kantenmaximalen Graphen ein,
welches gewissermaßen \emph{dual} zum Konzept des minimalen Graphen
ist. Wir wollen damit wieder eine untere Schranke zeigen.
\begin{definition}[Kantenmaximaler Graph\footnote{
vgl. \cite[S.12]{diestel}}]
Ein Graph $G\in \mathcal{G}_n$ heißt \emph{kantenmaximaler Graph}
der monotonen Graph-Eigenschaft $P_n$, wenn $G\notin P_n$ gilt,
aber für alle Kanten $e\notin G$ gilt: $G + e \in P_n$.
\end{definition}
Kantenmaximale Graphen sind also Graphen, die die Eigenschaft
nicht erfüllen, bei denen das Hinzufügen einer beliebigen
Kante aber dafür sorgt, dass die Eigenschaft erfüllt wird.
% Hier vielleicht Beispiel einfügen für kantenmaximalen Graphen ?

\begin{example}[Kantenmaximaler Graph]
Ein kantenmaximaler Graph der Eigenschaft $\operatorname{P}_4(\{K_3\})$
aus Beispiel~\ref{exmpl:Monotonie} ist folgender Graph:

\begin{center}
\begin{tikzpicture}[main_node/.style={circle,fill=black,minimum size=0.8em,inner sep=2pt]}]

    \node[main_node] (1) at (0,0) {};
    \node[main_node] (2) at (1, 0)  {};
    \node[main_node] (3) at (1, 1) {};
    \node[main_node] (4) at (0, 1) {};

    \draw (1) -- (2) -- (3) -- (4) -- (1);
\end{tikzpicture}
\end{center}

\end{example}

Mithilfe von kantenmaximalen Graphen können wir auch untere
Schranken beweisen, wie wir dies mit minimalen Graphen
in Satz \ref{thm:minDetLowerBound} getan haben. Hier ist
jedoch nicht die Anzahl der Kanten des Graphen ausschlaggebend,
sondern die Anzahl der \emph{fehlenden} Kanten.

\begin{Satz}[Kantenmaximaler Graph liefert untere Schranke]
\label{thm:EdgeMaxGraphLowerBound}
Sei $G\in \mathcal{G}_n$ ein kantenmaximaler Graph der monotonen
Graph-Eigenschaft $P_n \subseteq \mathcal{G}_n$.
Dann gilt für jeden deterministischen Algorithmus $\mathcal{A}$,
der $P_n$ entscheidet: 
$$ C(\mathcal{A}, G) \geq \binom{n}{2} - |E(G)|\,.$$
\end{Satz}
\begin{proof}
Der Beweis erfolgt analog zu dem von Satz \ref{thm:minDetLowerBound},
wobei nun die Kanten, die nicht zum Graphen gehören, vom Algorithmus
abgefragt werden müssen.
\end{proof}
Wir erhalten nun analog zum Fall der minimalen Graphen eine untere
Schranke für die randomisierte Abfragekomplexität:
\begin{corollary} [Kantenmaximaler Graph liefert untere Schranke
für die randomisierte Abfragekomplexität]
\label{thm:EdgeMaximalRandCompl}
Sei $G\in\mathcal{G}_n$ ein kantenmaximaler Graph der monotonen
Graph-Eigenschaft $P_n \subseteq \mathcal{G}_n$.
Dann gilt
$$ C_R(P_n) \geq \binom{n}{2} - |E(G)|\,.$$
\end{corollary}
\begin{proof}
Der Beweis erfolgt analog zum Beweis von Korollar \ref{cor:MinGraphRandCompl}
unter Verwendung von Satz \ref{thm:EdgeMaxGraphLowerBound}.
\end{proof}

\section{Konkrete Kriterien für untere Schranken}
Die bisher gezeigten unteren Schranken sind schwer auf konkrete
Fälle anzuwenden, da zuerst passende minimale Graphen oder kantenmaximale
Graphen gefunden werden müssen, die zu der Eigenschaft gehören.
In diesem Abschnitt entwickeln wir daher einige einfach zu überprüfende
Kriterien für Graph-Eigenschaften, sodass Eigenschaften, die diese
Kriterien erfüllen, eine hohe Abfragekomplexität haben.\\
Wir beschränken uns hierfür auf Eigenschaften, bei denen einer
der minimalen Graphen nur wenige nichtisolierte Ecken hat,
im Vergleich zur gesamten Eckenanzahl. Ein Beispiel dafür wäre
die Eigenschaft $\operatorname{P}_{100}(\{ \ \Square \ \})$,
denn hier hat der minimale Graph nur $4$ nichtisolierte Ecken,
aber Eingaben haben $100$~Ecken. \\
Wir gehen folgendermaßen vor: Wir konstruieren für Eigenschaften,
die gewisse Kriterien erfüllen, kantenmaximale Graphen mit 
relativ wenigen Kanten. Mithilfe von Korrollar 
\ref{thm:EdgeMaximalRandCompl} erhalten wir so eine untere Schranke
für die randomisierte Abfragekomplexität. \\
Die Bezeichnung $V_{>0}(G)$ verwenden wir für die
Menge der nichtisolierten Ecken des Graphen $G$,
d.h. die Menge aller Ecken mit mindestens einem Nachbar.

\subsection{Konstruktion kantenmaximaler Graphen}
Die Hauptidee: Wir nehmen einen minimalen Graphen mit einer
relativ geringen Eckenanzahl und wählen zwei benachbarte Ecken
$u$ und $v$. Wir konstruieren nun einen Graphen, indem wir aus dem
minimalen Graphen die Kante $uv$ herauslöschen und dann eine große
Anzahl von Kopien von $u$ und $v$ hinzufügen, ohne Kanten zwischen
Kopien von $u$ und Kopien von $v$.
Eine \emph{Kopie} einer Ecke $u$ ist hier
eine Ecke $u'$, die die gleiche Nachbarmenge wie $u$ hat, für
die also $N(u)=N(u')$ gilt.\\
Fügt man nun eine beliebige Kante zwischen einer Kopie von $u$ und einer
Kopie von $v$ ein, dann entsteht ein minimaler Graph. Wenn der
konstruierte Graph die Eigenschaft also nicht erfüllt, so sorgt 
ein Hinzufügen einer Kante dafür, dass die Eigenschaft erfüllt wird.
Folglich müssen alle diese entscheidenden Kanten abgefragt werden.
Da die Anzahl der in Frage kommenden Kanten groß ist, erhalten
wir eine gute untere Schranke für die Abfragekomplexität.
Fügt man alle Kanten hinzu, deren Ergänzung die Eigenschaft
nicht hervorruft, so erhält man sogar einen kantenmaximalen Graphen,
mit dem man dann mithilfe von Korollar \ref{thm:EdgeMaximalRandCompl}
direkt eine untere Schranke bekommt.
Im folgendem Beispiel führen wir diese Konstruktion einmal
exemplarisch durch.

% Hier Beispiel einfügen für die Konstruktion
\begin{example}[Konstruktion eines kantenmaximalen Graphen]
Wir betrachten die Graph-Eigenschaft $P_6(\{\Square\})$: ob der
Graph einen $4$-Kreis enthält.
Wir wählen nun zwei benachbarte Ecken $u$ und $v$ des minimalen
Graphen aus:
\begin{center}
\begin{tikzpicture}[main_node/.style={draw, circle, minimum size=0.8em,inner sep=2pt]}]

    \node[main_node] (1) at (0,0) {};
    \node[main_node] (2) at (1, 0)  {v};
    \node[main_node] (3) at (1, 1) {u};
    \node[main_node] (4) at (0, 1) {};

    \draw (1) -- (2) -- (3) -- (4) -- (1);
\end{tikzpicture}
\end{center}
Nun löschen wir die Kante zwischen $u$ und $v$ und fügen
in diesem Fall genau eine Kopie der Ecke $u$ und eine Kopie
der Ecke $v$ hinzu, sodass wir $6$ Ecken haben, da es 
sich um eine Eigenschaft auf $6$ Ecken handelt:
\begin{center}
\begin{tikzpicture}[main_node/.style={draw, circle, minimum size=1.5em,inner sep=2pt]}]

    \node[main_node] (1) at (0,0) {};
    \node[main_node] (2) at (2, -1)  {v};
    \node[main_node] (3) at (2, 3) {u};
    \node[main_node] (4) at (0, 2) {};
    
    \node[main_node] (5) at (3.5, 2) {u'};
    \node[main_node] (6) at (3.5, 0) {v'};

    \draw (1) -- (2); 
    \draw (3) -- (4) -- (1);
    \draw (5) -- (4);
    \draw (6) -- (1);
    \draw[dotted] (2) -- (3);
    \draw[dotted] (2) -- (5);
    \draw[dotted] (5) -- (6);
    \draw[dotted] (3) -- (6);
\end{tikzpicture}
\end{center}
Die Kanten, deren Hinzufügen einen Subgraphen \Square \ entstehen
lässt, werden hier gestrichelt dargestellt. Der konstruierte
Graph selbst enthält keinen solchen Subgraphen. Wie wir später
sehen werden, liegt dies daran, dass der minimale Graph regulär
ist. Um aus diesem konstruierten Graphen einen kantenmaximalen
Graphen zu machen, müssen nun noch Kanten hinzugefügt werden,
bis das Hinzufügen einer beliebigen, nicht zum Graphen gehörenden
Kante, einen Subgraphen entstehen lässt. Die Wahl der hinzuzufügenden
Kanten ist jedoch nicht eindeutig. Eine Möglichkeit ist
die folgende:
\begin{center}
\begin{tikzpicture}[main_node/.style={draw, circle, minimum size=1.5em,inner sep=2pt]}]

    \node[main_node] (1) at (0,0) {};
    \node[main_node] (2) at (2, -1)  {v};
    \node[main_node] (3) at (2, 3) {u};
    \node[main_node] (4) at (0, 2) {};
    
    \node[main_node] (5) at (3.5, 2) {u'};
    \node[main_node] (6) at (3.5, 0) {v'};

    \draw (1) -- (2); 
    \draw (3) -- (4) -- (1);
    \draw (5) -- (4);
    \draw (6) -- (1);
    
    \draw (2) -- (6);
    \draw (3) -- (5);
    
    \draw[dotted] (2) -- (3);
    \draw[dotted] (2) -- (5);
    \draw[dotted] (5) -- (6);
    \draw[dotted] (3) -- (6);
    
    % hinzugefügt gegenüber vorherigem Graphen.
    \draw[dotted] (5) -- (1);
    \draw[dotted] (6) -- (4);
\end{tikzpicture}
\end{center}
\end{example}

Die Konstruktion des Graphen formalisieren
wir nun:
\begin{definition}
[Duplizierungs-Graph $\Dupl(G, u, v, n)$]
Der Graph, der aus $G$ entsteht, indem man
die Kante zwischen $u\in V(G)$ und $v\in V(G)$ löscht
und dann $n$ Kopien von $u$ und $n$
Kopien von $v$ hinzufügt, wobei $n\in\mathbb{N}$,
bezeichnen wir mit $\Dupl(G, u, v, n)$.
\end{definition}

Damit wir einen kantenmaximalen Graphen erhalten, darf
der konstruierte Duplizierungs-Graph keinen minimalen Graphen
als Subgraphen enthalten. Also darf das Hinzufügen
von Kopien von Ecken keinen neuen minimalen Graphen
als Subgraphen erzeugen. Dies formalisieren wir 
folgendermaßen:
\begin{definition}[Duplizierungs-invarianter Graph]
Ein Graph $G$ heißt \emph{duplizierungs-invariant},
wenn es zwei benachbarte Ecken $u,v\in G$ gibt, 
sodass der Duplizierungsgraph $\Dupl(G, u, v, n)$,
für alle Werte von $n\in \mathbb{N}$, den Graphen
$G$ nicht als Subgraphen enthält.
\end{definition}

Mithilfe dieses Kriteriums können wir nun eine
untere Schranke für die randomsierte Abfragkomplexität
einiger Subgraph-Isomorphie-Eigenschaften (also Eigenschaften,
die nur einen minimalen Graphen haben) beweisen:
\begin{Satz}
[Untere Schranke für bestimmte Subgraph-Isomorphie-Eigenschaften]
\label{thm:SubgraphIsomorphismLowerBound}
Sei $H\in \mathcal{G}_n$ ein duplizierungs-invarianter Graph
mit genau $p = \big|V_{>0}(G)\big|$ nichtisolierten Ecken.
Dann gilt für die Subgraph-Isomorphie-Eigenschaft $P_n(\{H\})$:
$$ C_R(P_n(\{H\})) \geq 
\Big ( \Big \lfloor  \frac{n-p}{2} \Big \rfloor + 1 \Big)^{2} \geq
\frac{1}{4}(n-p+1)^2 =
\frac{1}{4}n^2 - \frac{1}{2}n(p-1) + \frac{1}{4}(p-1)^2\,.
$$
\end{Satz}
\begin{proof}
Da $H$ nach Voraussetzung duplizierungs-invariant ist und die 
Eigenschaft nur einen minimalen Graphen hat, gibt es
$u,v \in H$, sodass der Graph 
$G:= \Dupl(H, u, v, \big \lfloor \frac{n-p}{2} \big \rfloor)$
die Eigenschaft $P_n(\{H\})$ nicht erfüllt. \\
Ist $u'\in G$ eine Kopie von $u$ und $v' \in G$ eine Kopie von $v$,
so wird durch das Hinzufügen der Kante $u'v'$ als Subgraph ein
minimaler Graph erzeugt, da $H-u-v \subseteq G$ gilt und
$H \subseteq H-u-v + u' + v' + u'v'$. Da $G$ nach Konstruktion
jeweils $\big \lfloor \frac{n-p}{2} \big \rfloor+1$ Kopien von
$u$  und von $v$ hat (einschließlich $u$ und $v$), gibt es mindestens
$\Big( \Big \lfloor  \frac{n-p}{2} \Big \rfloor + 1 \Big)^{2}$
Kanten, deren Hinzufügen die Eigenschaft $P_n(\{H\})$ hervorruft.
Wir konstruieren nun einen kantenmaximalen Graphen $G'$ aus
$G$, indem wir nach und nach Kanten zu $G$ hinzufügen, die die
Eigenschaft unerfüllt lassen, bis dies nicht mehr möglich ist.
Dieser Graph $G'$ hat nun eine Kantenanzahl von:
$$ |E(G')| \leq \binom{n}{2} - 
\Big ( \Big \lfloor  \frac{n-p}{2} \Big \rfloor + 1 \Big)^{2}\,,$$
da alle Kanten zwischen Kopien von $u$ und $v$ nicht zu dem
kantenmaximalen Graphen gehören können. Wenden wir nun
Korollar \ref{thm:EdgeMaximalRandCompl} mit dem kantenmaximalen
Graphen $G'$ an, so erhalten wir unsere untere Schranke für
die Abfragekomplexität:
$$ C_R(P_n(\{H\})) \geq 
\Big (  \Big \lfloor  \frac{n-p}{2} \Big \rfloor + 1 \Big )^2$$
Da $\Big \lfloor  \frac{n-p}{2} \Big \rfloor \geq \frac{n-p-1}{2}$
gilt, erhalten wir dann durch Umformen:
\begin{equation*}
\Big ( \Big \lfloor  \frac{n-p}{2} \Big \rfloor + 1 \Big)^{2} \geq
\Big ( \frac{n-p+1}{2} \Big ) ^2 =
\frac{1}{4}(n-p+1)^2 =
\frac{1}{4}n^2 - \frac{1}{2}n(p-1) + \frac{1}{4}(p-1)^2\,. \qedhere
\end{equation*}
\end{proof}

\begin{example}[Anwendung dieses Satzes]
Der Graph $K_4 =$
\begin{tikzpicture}[main_node/.style={circle,fill=black},
inner sep=1.5pt, baseline=2pt]

    \node[main_node] (1) at (0,0) {};
    \node[main_node] (2) at (0.35, 0)  {};
    \node[main_node] (3) at (0.35, 0.35) {};
    \node[main_node] (4) at (0, 0.35) {};

    \draw (1) -- (2) -- (3) -- (4) -- (1);
    \draw (4) -- (2);
    \draw (3) -- (1);
\end{tikzpicture} ist duplizierungs-invariant, da die Kopien
der Ecken jeweils nur Grad $2$ haben. Zudem
hat er $p=4$ nichtisolierte Ecken. Für die Familie von
Eigenschaften $P_n(\{K_4\})$ mit $ n\geq 4$ erhalten wir also
mit Satz \ref{thm:SubgraphIsomorphismLowerBound} folgende
untere Schranke für die randomisierte Abfragekomplexität:
$$ C_R(P_n(\{K_4\})) \geq 
\Big ( \Big \lfloor  \frac{n-4}{2} \Big \rfloor + 1 \Big ) ^2 \geq
\Big ( \frac{n-3}{2} \Big ) ^2 = 
\frac{1}{4} n^2 - \frac{3}{2} n + \frac{9}{4} 
$$
Die gezeigte untere Schranke ist hier also nur um einen
konstanten Faktor von dem theoretischen Maximum
der randomisierten Abfragekomplexität
$\binom{n}{2} = \frac{1}{2}n^2 - \frac{1}{2}n$
entfernt.
\end{example}

\subsection{Kriterien für das Gelingen der Konstruktion}
Satz \ref{thm:SubgraphIsomorphismLowerBound}, der gute
untere Schranken für die randomisierte Abfragekomplexität
liefert, hat als Voraussetzung, dass der minimale Graph
\emph{duplizierungs-invariant} ist. Damit man den 
Satz möglichst direkt auf einen Fall anwenden kann, 
zeigen wir nun einige Kriterien dafür, wann ein
Graph duplizierungs-invariant ist.
\begin{Lemma}[Hinreichende Kriterien für Duplizierungs-Invarianz]
\label{thm:KriterienDuplizierungsInvariant}
Ein Graph $H$ ist duplizierungs-invariant, wenn eines
der vorliegenden Kriterien erfüllt ist:
\begin{enumerate}[label=\textbf{\emph{(\alph*)}}, leftmargin=*]
\item Es gibt eine Kante $uv\in H$, sodass sowohl
           der Grad von $u$ als auch der Grad von $v$
           minimal unter allen nichtisolierten Ecken von $H$ ist.
\item Es gibt eine Kante $uv \in H$ und eine Zahl
           $k\in \mathbb{N}$, sodass $u$ und $v$
           Teil einer $k$-Clique in $H$ sind, aber nicht
           in $H-uv$.
\end{enumerate}
\end{Lemma}
\begin{proof}
\hfill
\begin{enumerate}[label=\textbf{(\alph*)}, leftmargin=*]
\item      Wir betrachten den Graphen $\Dupl(H,u,v,n)$ für ein
           beliebiges $n\in \mathbb{N}$ und
           nehmen o.B.d.A. an, dass $\deg(u) \geq \deg(v)$ in $H$
           gilt. \\
           Da der Grad von $u$ und $v$ minimal unter allen
           nichtisolierten Ecken von $H$  ist, gibt es
           mindestens $|V_{>0}(H)| - 1$ Ecken mit Grad $\geq \deg(u)$ in $H$,
           nämlich mindestens alle nichtisolierten Ecken von $H$
           außer $v$.
           Im Graph $\Dupl(H,u,v,n)$ gibt es jedoch nur 
           $|V_{>0}(H)|-2$ Ecken mit Grad $\geq \deg(u)$, da alle
           Kopien von $u$ und $v$ höchstens Grad $\deg(u)-1$ haben
           und die Kante zwischen $u$ und $v$ gelöscht wurde.
           Somit kann $H$ kein Subgraph von $\Dupl(H,u,v,n)$ sein.
           
\item      Wir betrachten wieder den Graphen $\Dupl(H,u,v,n)$ für
           ein beliebiges $n\in \mathbb{N}$. Sei nun $m\in \mathbb{N}$
           die Anzahl der $k$-Cliquen in $H$. Da $u$ und $v$ nicht
           Teil einer $k$-Clique in $H-u-v$ sind, sind auch alle
           Kopien von $u$ und $v$ nicht Teil einer $k$-Clique in
           $\Dupl(H,u,v,n)$. Somit gibt es in $\Dupl(H,u,v,n)$ 
           genau so viele $k$-Cliquen wie in $H-u-v$. Da $u$ und
           $v$ Teil einer $k$-Clique in $H$ sind, aber 
           nicht in $H-u-v$, ist die Anzahl der $k$-Cliquen in
           $H-u-v$ und damit in $\Dupl(H,u,v,n)$ höchstens $m-1$
           und daher kleiner als $m$. Folglich enthält $\Dupl(H,u,v,n)$
           nicht den Subgraphen $H$. \qedhere
\end{enumerate}
\end{proof}

Mithilfe dieser Kriterien erhalten wir nun
eine direkte untere Schranke für die randomisierte Abfragekomplexität:
\begin{corollary}[Konkrete untere Schranken für Subgraph-Isomorphie-Eigenschaften]
Sei $n\in \mathbb{N}$ und $H\in \mathcal{G}_n$ ein Graph
mit $p=|V_{>0}(H)|$ nichtisolierten Ecken.

Erfüllt dann $H$ eines der folgenden Kriterien:
\begin{enumerate}[label=\textbf{\emph{(\alph*)}}, leftmargin=*]
\item Es gibt eine Kante $uv\in H$, sodass sowohl
           der Grad von $u$ als auch der Grad von $v$
           minimal unter allen nichtisolierten Ecken von $H$ ist.
\item Es gibt eine Kante $uv \in H$ und eine Zahl
           $k\in \mathbb{N}$, sodass $u$ und $v$
           Teil einer $k$-Clique in $H$ sind, aber nicht
           in $H-uv$.
\end{enumerate}
so gilt für die randomisierte Abfragekomplexität der Eigenschaft 
$P_n(\{H\})$:
$$ C_R(P_n(\{H\})) \geq
\Big{ ( } \Big \lfloor  \frac{n-p}{2} \Big \rfloor \Big{)}^{2} \geq
\frac{1}{4}n^2 - \frac{1}{2}n(p-1) + \frac{1}{4}(p-1)^2
$$
\end{corollary}
\begin{proof}
Der Graph $H$ ist nach Lemma \ref{thm:KriterienDuplizierungsInvariant}
duplizierungs-invariant. Es folgt somit mit 
Satz \ref{thm:SubgraphIsomorphismLowerBound} die entsprechende
untere Schranke für die randomisierte Abfragekomplexität.
\end{proof}

\begin{example}[Anwendungen des vorherigen Korollars]
Ist der Graph $H\in\mathcal{G}_n$ regulär, so haben
alle Ecken minimalen Grad. Der Graph $H$ erfüllt also Kriterium (a)
von Lemma \ref{thm:KriterienDuplizierungsInvariant}.
Die Eigenschaft $P_n(\{H\})$ hat somit eine randomisierte
Abfragekomplexität von 
$$ C_R(P_n(\{H\})) \geq
\frac{1}{4}n^2 - \frac{1}{2}n(p-1) + \frac{1}{4}(p-1)^2,$$
wobei $p=|V_{>0}(H)|$ die Anzahl nichtisolierter Ecken von $H$ ist. \\
Ist nun beispielsweise $H=\Square$, so gilt für $n\geq 4$:
$$ C_R(P_n(\{\ \Square \ \})) \geq
\frac{1}{4}n^2 - \frac{3}{2}n + \frac{9}{4}$$
\end{example}

\subsection{Limitierungen dieses Ansatzes}
Im vorherigen Abschnitt haben wir gezeigt, dass viele Eigenschaften,
die einen  minimalen Graphen mit wenigen Ecken haben, einen kantenmaximalen
Graphen mit wenigen Kanten haben. Es stellt sich nun die Frage,
ob man dies so weit verallgemeinern kann, dass alle Eigenschaften
mit minimalen Graphen mit wenigen Kanten auch einen kantenmaximalen
Graphen mit wenigen Kanten haben. Daraus würde eine allgemeine
untere Schranke für die randomisierte Abfragekomplexität folgen.
Wir zeigen nun jedoch, dass dies nicht allgemein gilt, indem wir
eine Eigenschaft finden, die einen minimalen Graphen mit wenigen
Kanten hat und dennoch nur kantenmaximale Graphen mit vielen Kanten. \\
Dies ist folgende Familie von Eigenschaften:
$$ P'_n := \{ \ G \in \mathcal{G}_n \ 
| \ \exists u\in V(G) \textup{ mit } \deg(u) = n-1 \ \}\,.$$
In Worten: Die Eigenschaft, dass es eine Ecke gibt,
die zu allen anderen Ecken eine Kante hat.
Die Eigenschaft $P'_n$ hat einen minimalen Graphen mit
$n-1$ Kanten. Die Anzahl der Kanten des minimalen Graphen
liefert also keine gute untere Schranke für die Abfragekomplexität.
Wir zeigen nun, dass alle kantenmaximalen Graphen von $P'_n$
eine sehr hohe Kantenanzahl haben. Also folgt auch aus der Kantenanzahl
der kantenmaximalen Graphen keine gute untere Schranke.
\begin{Proposition}[Alle kantenmaximalen Graphen von $P'_n$ 
             haben eine hohe Kantenanzahl]
Sei $G\in \mathcal{G}_n$ ein beliebiger kantenmaximaler Graph
von $P'_n$ für ein $n\in \mathbb{N}$. Dann gilt
$$ |E(G)| \geq \binom{n}{2} - n\,.$$
\end{Proposition}
\begin{proof}
Sei $E' := (V \times V) \backslash E(G)$ die Menge der Kanten, die nicht
zu $G$ gehören. Da $G$ kantenmaximal ist, ruft das Hinzufügen
einer dieser Kanten immer die Eigenschaft $P'_n$ hervor.
Folglich muss jede Kante in $E'$ eine inzidente Ecke mit Grad
$n-2$ haben. Diese Ecken sind für verschiedene Kanten in $E'$
paarweise verschieden voneinander, denn ansonsten wäre der
Grad der Ecke höchstens $n-3$. Da $G$ genau $n$ Ecken hat,
erhalten wir durch Abzählen, dass $|E'| \leq n$ gilt.
Wir erhalten somit:
\begin{equation*}
E(G) = \binom{n}{2} - |E'| \geq \binom{n}{2} - n\,. \qedhere
\end{equation*}
\end{proof}

Mittels Korollar \ref{thm:EdgeMaximalRandCompl} folgt also bestenfalls
eine untere Schranke von $C_R(P'_n) \geq n$. Somit können
wir mit unseren bisherigen Methoden keine gute untere Schranke
für diese Eigenschaft zeigen. Dafür müssen andere Methoden
entwickelt werden.

\chapter{Verallgemeinerung auf symmetrische Eigenschaften}
Die bisher betrachteten Graphen können mit einer Adjazenzmatrix
dargestellt werden. 
Ein Abfragen von Kanten entspricht dann
dem Abfragen eines Eintrages der Adjazenzmatrix.
Schreibt man die Einträge der Adjazenzmatrix als Folge von
Bits, so kann man eine Graph-Eigenschaft als Bitfolgen-Eigenschaft
auffassen, die eine gewisse Symmetrie aufweist, nämlich
die Invarianz gegenüber Graph-Isomorphismen.
In diesem Kapitel verallgemeinern wir das Konzept von
Graph-Eigenschaften nun auf Eigenschaften von Bitfolgen,
die eine beliebige Symmetrie aufweisen.
Anschliessend beschäftigen wir uns mit der Abfragekomplexität
solcher Eigenschaften.

Eine Bitfolge stellen wir hier als Element eines Vektorraums
über den endlichen Körper $\mathbb{F}_2$ der Ordnung $2$ dar.
Für die Bitfolge ``101`` würden wir also schreiben:
$ (1,0,1) \in \mathbb{F}_2^3$.

\section{Allgemeine symmetrische Eigenschaften}
Um die Symmetrie zu formalisieren, müssen wir zunächst
eine spezielle Gruppenoperation definieren:

\begin{definition}
[Operation der symmetrischen Gruppe $\mathbb{S}_m$ auf $\mathbb{F}_2^m$]
Die Gruppenoperation
$$\mathbb{S}_m \times \mathbb{F}_2^m \to \mathbb{F}_2^m, 
  \ (\sigma,g) \mapsto \sigma(g)$$
der symmetrischen Gruppe $\mathbb{S}_m$ auf dem
Vektorraum $\mathbb{F}_2^m$ ist so definiert,
dass für alle Indizes $1\leq i \leq m$ gilt:
$$ \sigma(g)_i = g_{\sigma(i)} $$
\end{definition}
Die symmetrische Gruppe permutiert also die Komponenten eines
Vektors. Eine Eigenschaft ist nun symmetrisch, wenn sie invariant
gegenüber dieser Gruppenoperation ist:\footnote{vgl. \cite[S.7]{Rivest}}

\begin{definition}[Symmetrische Eigenschaft]
Sei $m\in \mathbb{N}$ eine natürliche Zahl und
$S \leq \mathbb{S}_m$ eine Untergruppe der 
symmetrischen Gruppe vom Grad $m$. \\
Eine Teilmenge
$P_m \subseteq \mathbb{F}_2^m$ aller Bitfolgen der
Länge $m$ heißt \emph{$S$-symmetrische Eigenschaft}, wenn
für alle $\sigma \in S$ und alle $g\in \mathbb{F}_2^m$ gilt:
$$ \sigma(g)\in P_m \iff g \in P_m\,.$$ 
\end{definition}

Eine Graph-Eigenschaft kann man als symmetrische
Eigenschaft auffassen. Hierbei ist $S$ die Gruppe
der Graph-Isomorphismen.
Analog zu Graph-Eigenschaften definiert man
\emph{monotone} symmetrische Eigenschaften. 
Ebenso kann man, analog zu den minimalen Graphen bei
Graph-Eigenschaften, \emph{minimale Muster} definieren.
Auch im allgemeinen Fall können wir dann die Notation
$P_m(\mathcal{H})$ für die monotone Eigenschaft
von Bitfolgen der Länge $m$ mit der Menge an minimalen
Mustern $\mathcal{H}\subseteq \mathbb{F}_2^m$ verwenden.

\section{Abfragekomplexität vollständig symmetrischer Eigenschaften}
In diesem Abschnitt betrachten wir exemplarisch
den Fall, dass $S=\mathbb{S}_m$ die gesamte Symmetriegruppe
ist, was einer vollständigen Symmetrie der Eigenschaften entspricht.
Ist dann $P_m\subseteq \mathbb{F}_2^m$ für ein $m\in\mathbb{N}$ eine monotone 
$S$-symmetrische Eigenschaft, so muss 
$P_m$ von der Form 
$$ P_m= \{ g\in \mathbb{F}_2^m \ |
\ g \textup{ hat mindestens } k\textup{-mal die Komponente } 1 \ \}$$
sein, denn erfüllt $g\in \mathbb{F}_2^m$ die Eigenschaft
$P_,$, so muss dies auch für alle $g'=\sigma(g)\in\mathbb{F}_2^m$
mit $\sigma\in S$ gelten. Da $S=\mathbb{S}_m$ alle Permutationen
umfasst, sind für $g'\in P_m$ alle Vektoren mit
genau so vielen Komponenten mit Wert $1$ wie $g$ möglich. Aus der
Monotonie von $P_m$ folgt dann, dass alle Vektoren mit
mindestens dieser Anzahl an Komponenten mit Wert $1$ zu
$P_m$ gehören.
\begin{Satz}
\label{thm:SymmetrischeGruppe}
Alle $\mathbb{S}_m$-symmetrischen Eigenschaften 
$P_m \subseteq \mathbb{F}_2^m$ haben eine
deterministische Abfragekomplexität
von $C(P_m) = m$.
\end{Satz}
\begin{proof}
Wie oben gezeigt, ist $P_m$ von der Form
$$ P_m= \{ g\in \mathbb{F}_2^m \ |
\ g \textup{ hat mindestens } k\textup{-mal die Komponente } 1 \ \}\,,$$
für ein $k\in \mathbb{N}$.
Aus dem Verhalten eines beliebigen deterministischen Algorithmus
$\mathcal{A}$ konstruieren wir nun einen Input $g$,
sodass $C(\mathcal{A},g)=m$ gilt. Auf die ersten $m-k$
Abfragen von $\mathcal{A}$ antworten wir mit "`0"'.
Der Input erfüllt nun genau die Eigenschaft $P_m$, wenn
alle restlichen $k$ Bits den Wert "`1"' haben.
Antworten wir also von nun an mit "`1"', so muss der 
Algorithmus $\mathcal{A}$
den entsprechenden Input $g$ bis auf das letzte Bit abfragen,
um zu entscheiden, ob $g\in P_m$ gilt. Daraus folgt
$C(\mathcal{A}) \geq C(\mathcal{A}, g) = m$ und da unsere
Wahl von $\mathcal{A}$ beliebig war: $C(P_m)=m$.
\end{proof}

\section{Algebraische Formulierungen}

Die in Abschnitt \ref{sec:queryComplexity} getroffenen
Definitionen stützen sich auf die Darstellung eines 
Algorithmus als Entscheidungsbaums.
Diese Sichtweise macht es schwierig, übliche mathematische
Methoden anzuwenden, um eine untere Schranke für die
Abfragekomplexität zu beweisen.
Indem wir nun eine vollständig algebraisch
formulierte Definition für die Abfragekomplexität angeben,
sind wir später jedoch in der Lage, algebraische Methoden zu verwenden,
wie z.B. in Abschnitt \ref{sec:AlgebraischeAnsaetze}.
% Verschiedene Möglichkeiten, Algorithmen / Abfragekomplexität
% algebraisch zu charakterisieren.

\subsection{Eine erste Formulierung}
\label{sec:AlgebraischeCharakterisierung}
Ein Algorithmus wird bezüglich der Abfragekomplexität vollständig
durch die Abfragereihenfolge der Bits festgelegt.
Der Algorithmus kann jedoch die Reihenfolge der nächsten
abgefragten Bits an die bisher erhaltene Information anpassen.
Ein Algorithmus $\mathcal{A}$ für eine Eigenschaft
auf $m$ Bits lässt sich also als Abbildung der Menge aller
Bitfolgen auf die Menge aller Permutationen darstellen:
$$ \varphi_\mathcal{A}: \mathbb{F}_2^m \to \mathbb{S}_m,
   ~g \mapsto \varphi_\mathcal{A}(g).$$
Hierbei gibt $\sigma = \varphi_\mathcal{A}(g)$ an, welches
Bit an der jeweiligen Stelle abgefragt wird,
d.h. $\sigma(k)=i$ bedeutet, dass an $k$-ter
Stelle das Bit mit Index $i$ abgefragt wird.

Ein Algorithmus kann jedoch die Reihenfolge der 
abgefragten Bits jedoch nicht nachträglich ändern. Deswegen
korrespondieren nur die Abbildungen $\varphi_\mathcal{A}$,
zu einem richtigen Algorithmus, bei denen die Reihenfolge
der bisher abgefragten Bits konstant bleibt.
Algebraisch ausgedrückt: Es muss für alle Eingaben
$g\in \mathbb{F}_2^m$ und Bitindizes $1\leq i \leq m$
mit Abfrageposition $k=(\varphi_\mathcal{A}(g))^{-1}(i)$
gelten:
\begin{equation}
\label{eq:NichtNachtraeglichAendern}
\varphi(g)|_{[k]} = \varphi(g+e_i)|_{[k]}.
\end{equation}
Hierbei ist $e_i\in \mathbb{F}_2^m$
der $i$-te kanonische Einheitsvektor
und wir verwenden die Notation $[k]=\{1,2, \dots, k\}$.
Erfüllt eine Abbildung $\varphi_\mathcal{A}$ diese
Bedingung, so korrespondiert sie eindeutig
zu einem Algorithmus. Somit können wir nun
einen Algorithmus als solch eine Abbildung darstellen.
Dies ermöglicht es uns, auch die Abfragekomplexität
einer solchen Abbildung zu definieren.

Sei dafür $\mathcal{H}$ die Menge an minimalen
Mustern einer Eigenschaft $P_m(\mathcal{H})$.
Zudem sei $g\in P_m(\mathcal{H})$ ein Input, der die
Eigenschaft $P_m(\mathcal{H})$ erfüllt.
Die Abfragekomplexität für diesen Input $g$
ist dann definiert als Anzahl an abgefragten Bits
bis ein minimales Muster "`entdeckt"' wurde.
Formal ausgedrückt:
$$ C(\varphi_\mathcal{A}, g) :=
\argmin_{k\in\mathbb{N}} \Big(\exists H\in\mathcal{H}:
H \leq \sum_{i=1}^k g_{\varphi(g)(i)} \Big).
$$
Die Notation $A\leq B$ bedeutet hier, dass
für $A=(a_1, a_2, \dots, a_m)\in \mathbb{F}_2^m$
und $B=(b_1, b_2, \dots, b_m)\in \mathbb{F}_2^m$
die komponentenweise Ungleichung $a_i \leq b_i$
für alle $1\leq i\leq m$ gilt und $g_j$ steht für
die $j$-te Komponente von $g$, ausgedrückt als
Vektor.

Erfüllt $g\in\mathbb{F}_2^m$ hingegen nicht die
Eigenschaft $P_m(\mathcal{H})$, so wird ein Algorithmus
natürlich nie ein minimales Muster finden. Deswegen
muss die Abfragekomplexität für einen solchen
Input anders definiert werden. Da dies sehr 
technisch und umständlich ist, führen wir
dies nicht weiter aus.

\subsection{Eine elegantere Formulierung}
Damit eine Abbildung auch zu einem Algorithmus
korrespondiert, muss sie die relativ komplizierte
Bedingung~(\ref{eq:NichtNachtraeglichAendern})
erfüllen. Wir wollen nun solche Abbildungen
auf eine andere, natürlichere
Weise charakterisieren, sodass keine komplexe Bedingung
dafür erforderlich ist.

Ein Algorithmus kann so verstanden werden, dass die
Abfragereihenfolge so lange konstant bleibt, bis er
eine "`1"' als Antwort auf eine Abfrage erhält.
Dann wird die zukünftige Abfragereihenfolge
permutiert. Dies führt zu folgender Charakterisierung:

\emph{Eine Familie von Abbildungen 
$\psi_k:\mathbb{F}_2^k \to \mathbb{S}_{m-k-1}$
mit $0 \leq k \leq m-3$ einschließlich einer Startreihenfolge
$\psi_{-1}\in\mathbb{S}_m$ legt eindeutig einen Algorithmus fest.}
Hierbei kann man $k$ als die Anzahl bisher erfolgter Abfragen
auffassen. Der Wert $\psi_k(g)$ ist hier zu interpretieren
als Permutation der zukünftigen Abfragereihenfolge, wenn
der Algorithmus als nächstes eine "`1"' zurückgeliefert bekommt.
Wird dem Algorithmus hingegen eine "`0"' zurückgeliefert, so
bleibt die Abfragereihenfolge unverändert.
Da jeweils nur die zukünftige Abfragereihenfolge permutiert 
wird, ist keine zusätzliche Bedingung wie 
(\ref{eq:NichtNachtraeglichAendern}) notwendig, um zu garantieren,
dass die Familie von Abbildungen einem Algorithmus entspricht.
Jedoch ist die Abfragekomplexität mit dieser Charakterisierung
nur sehr umständlich zu definieren.

Da eine solche Familie von Abbildungen eindeutig
einem Algorithmus entspricht, können wir, mithilfe dieser Darstellung,
die Anzahl aller Algorithmen für Eigenschaften auf $m$ Bits
berechnen. Da $|\mathbb{S}_{m-k-1}|=(m-k-1)!$ und
$|\mathbb{F}_2^k| = 2^k$ gilt, gibt es
insgesamt $\big((m-k-1)!\big)^{2^k}$ Abbildungen der Form
$\psi_k:\mathbb{F}_2^k \to \mathbb{S}_{m-k-1}$.
Für die Startabbildung $\psi_{-1}\in\mathbb{S}_m$ gibt
es $|\mathbb{S}_m| = m!$ Möglichkeiten.
Es gibt somit
$$m!\cdot \prod_{k=0}^{m-3} \big((m-k-1)!\big)^{2^k} $$
Familien von Abbildungen und ebenso viele Algorithmen
für Bitfolgeneigenschaften mit $m$ Bits.
Mit $m=5$ erhalten wir bereits 
$$5!\cdot \prod_{k=0}^2 \big((5-k-1)!\big)^{2^k}
= 5!\cdot 4! \cdot 3!^2 \cdot 2!^4
= 120 \cdot 24 \cdot 36 \cdot 16 = 1658880
$$
verschiedene Algorithmen. Für $m=8$ erhalten wir sogar
über $2,9 \cdot 10^{55}$ verschiedene Algorithmen. Diese
Zahl ist weit größer als die Anzahl möglicher 
Spielsituationen beim Schach, die kleiner als $5\cdot 10^{52}$
ist.\footnote{Diese obere Schranke wird gegeben in:
\cite[S.172]{Allis}.}
Dies erklärt eventuell, warum es so schwierig ist, untere
Schranken für die Abfragekomplexität zu beweisen. Denn
es kommt eine extrem große Anzahl möglicher Algorithmen
in Betracht.

\section{Algebraische Ansätze}
\label{sec:AlgebraischeAnsaetze}
In diesem letzten Abschnitt wollen wir einige algebraische
Ansätze aufzeigen, die für Beweise von unteren
Schranken für die Abfragekomplexität nützlich sein können.
Wir verwenden hierfür die Charakterisierung von Algorithmen
aus Abschnitt \ref{sec:AlgebraischeCharakterisierung}.

Mit $\Hom(\mathbb{F}_2^m, \mathbb{S}_m)$ bezeichnen wir die
Menge aller Abbildungen der Form 
$\varphi: \mathbb{F}_2^m \to \mathbb{S}_m$.
Auf dieser Menge definieren wir nun eine Verknüpfung
mit der Symmetriegruppe $S$:

\begin{definition}
[Symmetrieverknüpfung]
\label{def:Symmetrieverknuepfung}
\ \\
Die äußere Verknüpfung
\begin{align*} 
\circ: S \times \Hom(\mathbb{F}_2^m, \mathbb{S}_m) &\to 
\Hom(\mathbb{F}_2^m, \mathbb{S}_m) \\
(\sigma, \varphi) &\mapsto \varphi',
\end{align*}
der Symmetriegruppe $S$ auf die Menge der Algorithmen 
$\Hom(\mathbb{F}_2^m, \mathbb{S}_m)$, wobei $\varphi'$ definiert ist durch 
$$\varphi'(g)=\sigma^{-1} \cdot \varphi(\sigma(g)),$$
bezeichnen wir als \emph{Symmetrieverknüpfung} von
$S$ auf  $\Hom(\mathbb{F}_2^m, \mathbb{S}_m)$.
\end{definition}

Die Symmetrieverknüpfung hat die interessante Eigenschaft,
dass die Abfragekomplexität eines Algorithmus invariant unter
ihr ist.

\begin{Satz}[Invarianz der Abfragekomplexität unter der Symmetrieverknüpfung]
Sei $S\leq \mathbb{S}_m$ eine Untergruppe der symmetrischen Gruppe vom
Grad $m$ und $P_m \subseteq\mathbb{F}_2^m$ eine $S$-symmetrische
Eigenschaft. Ist dann $\sigma \in S$ und
$\varphi_\mathcal{A}:\mathbb{F}_2^m \to \mathbb{S}_m$ ein Algorithmus,
so gilt für die Abfragekomplexität des Algorithmus $\varphi$
und des von der Symmetrieverknüpfung induzierten Algorithmus
$\sigma \circ \varphi_\mathcal{A}$:
$$C(\varphi_\mathcal{A}) = C(\sigma \circ \varphi_\mathcal{A}).$$
\end{Satz}
\begin{proof}
Wir zeigen zunächst, dass 
$C(\sigma \circ \varphi_\mathcal{A}) \geq C(\varphi_\mathcal{A})$ gilt. 
Sei $g\in\mathbb{F}_2^m$ der Worst-Case Input für $\varphi_\mathcal{A}$,
der $C(\varphi_\mathcal{A}, g) = C(\varphi_\mathcal{A})$ erfüllt.
Wir betrachten nun die Komplexität des Inputs $g' = \sigma^{-1}(g)$
für den Algorithmus $\sigma \circ \varphi_\mathcal{A}$.
Es folgt nun aus der Definition der Symmetrieverknüpfung:
\begin{equation}
\label{eq:Symmetrie}
\sigma \circ \varphi_\mathcal{A} (g')
= \sigma \circ \varphi_\mathcal{A} (\sigma^{-1}(g)) 
= \sigma^{-1} \varphi_\mathcal{A}(\sigma \cdot \sigma^{-1} (g))
= \sigma^{-1} \cdot \varphi_\mathcal{A}(g).
\end{equation}

Für eine Abfrageposition $k$ erhalten wir daraus 
$\sigma \circ \varphi_\mathcal{A}(g')(k) 
= \sigma^{-1} \cdot \varphi_\mathcal{A}(g)(k)$.

Wir können o.B.d.A. annehmen, dass der Worst-Case Input $g$ die
Eigenschaft $P_m$ erfüllt, denn erfüllt $g$ die Eigenschaft
$P_m$ nicht, so können wir einen Input  mit gleicher
Abfragekomplexität bilden, indem wir das letzte abgefragte
Bit von $g$ auf den Wert "`1"' setzen, denn das letzte
abgefragte Bit muss entscheidend für $g\in P_m$ sein.

Weiterhin können wir o.B.d.A. annehmen, dass $g$ nur 
ein einziges minimales Muster enthält, denn setzen wir
alle nicht abgefragten Bits auf den Wert "`0"', so hat
der entstehende Input die gleiche Abfragekomplexität
und enthält nur ein einziges minimales Muster.
Wir nennen dieses minimale Muster $h\in \mathbb{F}_2^m$.

Da die Eigenschaft $P_m$ $S$-symmetrisch ist und 
$\sigma\in S$ gilt, enthalten $g$ und $g'=\sigma^{-1}(g)$
unter der Symmetriegruppe $S$ identische minimale Muster von $P_m$.
Folglich enthält $g'=\sigma^{-1}(g)$ auch nur einziges minimales Muster,
nämlich das Bild $\sigma^{-1}(h)$ des minimalen Musters von $h$ unter
$\sigma^{-1}$.

Im Folgenden bezeichnen wir für eine einfache Lesbarkeit die
$i$-te Komponente eines Vektors $a\in\mathbb{F}_2^m$ mit
$a[i]$ anstatt $a_i$.
Da $g$ die Abfragekomplexität $C(\varphi_\mathcal{A}, g)$
hat und nach Annahme $g$ die Eigenschaft $P_m$ erfüllt,
muss das letzte abgefragte Bit von $g$ zu dem
minimalen Muster $h$ gehören. Es gilt also 
$h[\varphi_\mathcal{A}(g)(C(\varphi_\mathcal{A}, g))]= 1 \in \mathbb{F}_2$.
Wir erhalten nun für den Input $g'$ zu dem
Algorithmus $\sigma \circ \varphi_\mathcal{A}$ mithilfe der 
Gleichung (\ref{eq:Symmetrie}):
$$\sigma^{-1}(h)[\sigma \circ \varphi_\mathcal{A}(g')(C(\varphi_\mathcal{A}, g))]
\overset{\textup{Def. \ref{def:Symmetrieverknuepfung}}}{=}
\sigma^{-1}(h)[\sigma^{-1} \cdot \varphi_\mathcal{A}(g)(C(\varphi_\mathcal{A}, g))]
\overset{(\ref{eq:Symmetrie})}{=}
h[\varphi(g)(C(\varphi_\mathcal{A}, g))]
= 1 \in \mathbb{F}_2.$$
Dies bedeutet, dass der Algorithmus $\sigma \circ \varphi_\mathcal{A}$ an Position
$C(\varphi_\mathcal{A}, g)$ ein Bit des minimalen Musters abfragt.
Der Algorithmus $\sigma \circ \varphi_\mathcal{A}$ braucht für den
Input $g'=\sigma^{-1}(g)$ also mindestens eine Abfragekomplexität
von $C(\varphi_\mathcal{A}, g)$. Da $g$ als Worst-Case Input für
$\varphi_\mathcal{A}$ gewählt wurde, gilt somit
$$ C(\sigma \circ \varphi_\mathcal{A}) \geq C(\varphi_\mathcal{A}).$$

Umgekehrt gilt
$\sigma^{-1}\circ \sigma \circ \varphi_\mathcal{A} = \varphi_\mathcal{A}$,
da für alle Inputs $g\in\mathbb{F}_2^m$ gilt:
$$\sigma^{-1}\circ \sigma \circ \varphi_\mathcal{A}(g)
= \sigma^{-1} \circ \sigma^{-1}(\varphi_\mathcal{A}(\sigma(g)))
= \sigma \cdot \sigma^{-1} \varphi_\mathcal{A}(\sigma^{-1}\cdot \sigma(g))
= \varphi_\mathcal{A}(g).
$$
Wir erhalten also als zweite Ungleichung
$C(\varphi_\mathcal{A}) = C(\sigma^{-1}\circ \sigma \circ \varphi_\mathcal{A})
\geq C(\sigma \circ \varphi_\mathcal{A})$
und wenn wir beide Ungleichungen kombinieren, unsere Aussage
\begin{equation*}
C(\sigma \circ \varphi_\mathcal{A}) = C(\varphi_\mathcal{A}).
\qedhere
\end{equation*}
\end{proof}
Die Symmetrieverknüpfung erlaubt uns, Algorithmen
in eine Normalform zu überführen ohne deren Abfragekomplexität
zu beeinflussen. Dies vereinfacht Beweise erheblich.
Als Beispiel dafür geben wir zum Abschluss einen eleganteren und
direkten alternativen
Beweis von Satz \ref{thm:SymmetrischeGruppe}.
\begin{proof}
[Alternativer Beweis von Satz \ref{thm:SymmetrischeGruppe}]
Sei $\varphi_\mathcal{A}$ ein beliebiger Algorithmus,
der $P_m$ entscheidet und die Permutation
$\sigma~=~\varphi_\mathcal{A}(\boldsymbol{0})\in\mathbb{S}_m=S$
die Abfragereihenfolge des Algorithmus, wenn der Input
der Nullvektor ist. Wir erhalten den Algorithmus
$\psi_\mathcal{A} = \sigma \circ \varphi_\mathcal{A}$
für den aus der Definition der Symmetrieverknüpfung
$\psi_\mathcal{A}(\boldsymbol{0})
= \sigma^{-1} \cdot \sigma = \operatorname{id}_{\mathbb{S}_m}$ folgt.
Betrachten wir den Input $g=0^{m-k}1^k \in \mathbb{F}_2^m$,
so fragt $\psi_\mathcal{A}$ zuerst alle Nullen ab und
erst danach die Einsen. Da $g$ genau dann die Eigenschaft
$P_m$ erfüllt wenn alle $k$ verbliebenen Bits den Wert
"`1"' haben, hat $\psi_\mathcal{A}$ eine Abfragekomplexität
von $C(\psi_\mathcal{A}, g) = m$.

Aus dem vorherigen Satz folgt nun, dass 
$\psi_\mathcal{A}$ und $\varphi_\mathcal{A}$ die gleiche
Abfragekomplexität haben, es gilt also
$C(\varphi_\mathcal{A}) = C(\psi_\mathcal{A}) 
\geq C(\psi_\mathcal{A},g) = m$.
Da $\varphi_\mathcal{A}$ nur als beliebiger korrekter Algorithmus
vorausgesetzt wurde, erhalten wir eine Abfragekomplexität der Eigenschaft
von $C(P_m)=m$.
\end{proof}

%\vspace*{1cm}

%\begingroup
%\let\clearpage\relax
\chapter{Fazit und Ausblick}
%\endgroup
%\vspace*{-0.2cm}
Thema dieser Facharbeit waren untere Schranken für die
Abfragekomplexität monotoner symmetrischer Eigenschaften.
Wir haben uns zuerst mit Graph-Eigenschaften beschäftigt 
und quadratische untere Schranken für Subgraph-Isomorphie-
Eigenschaften gezeigt, bei denen der einzige minimale
Graph wenige nichtisolierte Ecken hat und die
Eigenschaft der Duplizierungs-Invarianz besitzt.
Zugleich haben wir die Grenzen unseres Ansatzes
aufgezeigt, was noch einmal verdeutlicht, dass 
weiterhin neue Methoden entwickelt werden sollten.

Im zweiten Teil beschäftigten wir uns mit der
Theorie allgemeiner symmetrischer Eigenschaften.
Hierfür haben wir eine optimale untere Schranke für
den Spezialfall gezeigt, dass die Symmetriegruppe die gesamte
symmetrische Gruppe ist. Danach wurden
einige algebraische Charakterisierungen von Algorithmen
und der Abfragekomplexität vorgestellt. Diese Formulierungen
können genutzt werden, um mit algebraischen Methoden
die Abfragekomplexität zu untersuchen, ohne auf 
Entscheidungsbäume und ähnliche schwierig formal zu 
definierende Begriffe zurückzugreifen. In einem letzten
Abschnitt haben wir gezeigt, dass eine Normalform
für Algorithmen existiert, die die Abfragekomplexität
unverändert lässt. Dies vereinfacht Beweise
in zukünftigen Untersuchungen, da untere Schranken
für die Abfragekomplexität nun nur noch für Algorithmen
in Normalform gezeigt werden müssen.
\\

In zukünftigen Arbeiten können viele der hier
vorgestellten Methoden und Sätze noch verbessert werden.
So kann die untere Schranke für die Abfragekomplexität
von Subgraph-Isomorphie-Eigenschaften aus Satz
\ref{thm:SubgraphIsomorphismLowerBound} auf beliebige
Subgraph-Eigenschaften verallgemeinert werden. 
Hierfür müssen die Kriterien für Duplizierungs-Invarianz
angepasst werden an die Tatsache, dass es dann
eine Familie unterschiedlicher minimaler Graphen gibt.
Desweiteren kann die untere Schranke für die Abfragekomplexität
für einige Fälle von asymptomisch $\frac{1}{4}n^2$
auf $\frac{1}{2}n^2$ verbessert werden, indem man, 
anstatt Kopien von zwei verschiedene Ecken, Ecken
einfügt, deren Menge an Nachbaren die Nachbarsmengen
der beiden verschieden Ecken vereinigt. Dabei müssen
jedoch strengere Kriterien an den betrachteten minimalen
Graphen gestellt werden.

Für die Symmetrieverknüpfung aus dem letzten Abschnitt
kann man zeigen, dass diese sogar eine Gruppenoperation
darstellt, wenn die betrachtete Symmetriegruppe $S$ 
abelsch ist. Ein Thema weiterer Untersuchungen kann
dann die Anwendung von Sätzen der Gruppentheorie
wie z.B. der Bahnengleichung auf die Abfragekomplexität
von Eigenschaften mit abelschen Symmetriegruppen sein.\footnote{
Für einen Überblick über algebraische Methoden, siehe: \cite{Bosch} }
Im Allgemeinen sollten die in dieser Facharbeit vorgestellten
algebraischen Ansätze mit algebraischen Mitteln
weiter verfolgt werden, da die Algebra einen großen
Fundus von Methoden anbietet, die bisher noch nicht
angewandt wurden.




\printbibliography[title={\ Literatur}]

\iftoggle{book}
{ 
    \newpage
    \thispagestyle{empty}
    \mbox{}
    \addtocounter{page}{-1}
}{}

\chapter*{Erklärung über die selbstständige Anfertigung der Arbeit}

\thispagestyle{empty}

Hiermit erkläre ich, dass ich die vorliegende Facharbeit
selbstständig verfasst und keine anderen als die im Literaturverzeichnis
angegebenen Hilfsmittel verwendet habe. \\ \\

Mainz, der \today \\ \\

\rule{7cm}{0.4mm}
\vspace*{0.2cm}

Erik Diessel

\iftoggle{book}
{
    \newpage
    \thispagestyle{empty}
    \mbox{}
    \addtocounter{page}{-1}
}{}

\end{document}
