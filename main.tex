\documentclass[a4paper]{scrreprt}
\usepackage[utf8]{inputenc}
\usepackage[ngerman]{babel}
\usepackage{amsmath}
\usepackage{amsthm}
\usepackage[backend=biber,style=authortitle]{biblatex}
\usepackage[babel]{csquotes}
\usepackage{tikz}
\usepackage{amsfonts}
\usepackage{blindtext}
\usepackage{hyperref}
\usepackage{geometry}
\geometry{
bottom=25mm,
top=20mm,
left=20mm,
right=20mm
}

\newtheorem{definition}{Definition}
\newtheorem{Satz}[definition]{Satz}
\newtheorem{conjecture}[definition]{Vermutung}
\newtheorem{corollary}[definition]{Korollar}
\theoremstyle{definition}
\newtheorem{example}{Beispiel}

\addbibresource{literature.bib}

\DeclareMathOperator\Min{Min}
\DeclareMathOperator\Dupl{Dupl}

\newcommand{\Square}{
\begin{tikzpicture}[main_node/.style={circle,fill=black},
inner sep=1.5pt, baseline=2pt]

    \node[main_node] (1) at (0,0) {};
    \node[main_node] (2) at (0.35, 0)  {};
    \node[main_node] (3) at (0.35, 0.35) {};
    \node[main_node] (4) at (0, 0.35) {};

    \draw (1) -- (2) -- (3) -- (4) -- (1);
\end{tikzpicture}
}

\title{Untere Schranken für die Abfragekomplexität 
       monotoner symmetrischer Eigenschaften}
\subtitle{Facharbeit}
\author{Erik Diessel}
\begin{document}

\maketitle

\begin{abstract}
\begin{center}
\bf{Kurzfassung}
\end{center}
Diese Facharbeit beschäftigt sich mit unteren Schranken
für die Abfragekomplexität von monotonen symmetrischen
Eigenschaften von Bitfolgen, besonders für Graph-Eigenschaften.
\end{abstract}

\tableofcontents
\thispagestyle{empty}

\chapter{Einleitung}
Die Frage, welche Komplexität ein Problem hat, d.h.
wie viele Ressourcen ein Algorithmus aufbringen muss,
um ein Problem zu lösen, ist eine der dominierenden
Fragestellungen der theoretischen Informatik.
Der bekannteste Fall ist hier die Frage, ob die beiden
Komplexitätsklassen $P$ und $NP$ identisch sind. Diese
Frage dreht sich um die Zeitkomplexität, die bestimmte
Probleme benötigen. Obwohl dies seit mehr als 40 Jahren
mit großem Aufwand untersucht wird, hat man noch
immer keine Lösung gefunden und es wird vermutet, dass
man auch nicht mit einer Lösung in der nahen Zukunft
rechnen kann \footnote{\cite{PvsNP}}.
Obwohl diese Fragestellung ursprünglich aus der
Informatik stammt, gilt sie inzwischen als eines der
größten ungelösten Probleme der Mathematik. Das Clay
Mathematics Institute stufte es als ein ``Millenium Problem``
der Mathematik ein und hat einen Preis von
1 Million Dollar für seine Lösung ausgelobt
\footnote{vgl. die offizielle Problembeschreibung:
\cite{PvsNPOfficial}}. \\
Die Komplexität eines Problems zu ermitteln hat
große Relevanz für die Praxis, da so die Entwickler
von Algorithmen wissen, wie effizient ein Algorithmus
theoretisch überhaupt sein kann. \\
Es wird vermutet, dass $P\neq NP$ gilt. Um dies zu beweisen
müsste man eine untere Schranke für die Zeitkomplexität
gewisser Probleme finden. Bis heute sind jedoch
keine adäquaten Methoden bekannt. \\
In dieser Facharbeit beschäftigen wir uns daher mit
der  Abfragekomplexität von Eigenschaften. Im Gegensatz
zur Zeitkomplexität ist es hier möglich gute
untere Schranken zu beweisen. Die Entwicklung
neuer Methoden für diesen ''einfachen'' Fall ermöglicht
es vielleicht später, diese, in angepaster Form, auf
die Zeitkomplexität anzuwenden.\\
Im Kontext von ungerichteten Graphen
ist die Abfragekomplexität die Anzahl
an Abfragen der Form ''Besteht eine Kante zwischen
der Ecke $u$ und der Ecke $v$ ?'', die ein Algorithmus
benötigt, um zu entscheiden, ob ein gegebener Graph
eine Eigenschaft erfüllt. Eine Graph-Eigenschaft ist
dabei unabhängig von der konkreten Benennung der Knoten.
Von Rivest und Vuillemin wurde gezeigt,
dass die Abfragekomplexität
im Fall von monotonen Graph-Eigenschaften, die beim 
Hinzufügen von Kanten erhalten bleiben, asymptotisch
quadratisch in der Anzahl der Knoten
ist \footnote{\cite{Rivest}}. Für die von
ihnen gezeigte untere Schranke für die Komplexität
$C(P_n) \geq \frac{1}{16}n^2$ wird bis heute noch
versucht, den konstanten Faktor zu erhöhen. Die bisher beste
untere allgemeine Schranke wurde von Scheidweiler
und Triesch 2013 gezeigt\footnote{\cite{Scheidweiler}}:
$C(P_n) \geq \frac{2}{3}n^2 - o(n^2)$.


\chapter{Die Abfragekomplexität von monotonen Graph-Eigenschaften}
\section{Grundlegende Definitionen}
\subsection{Graph-Eigenschaften}
Im graphentheoretischen Teil folgen wir größtenteils
der Notation eines Standardwerkes der Graphentheorie \footnote{\cite{diestel}}. \\
Mit $\mathcal{G}_n$ bezeichnen wir die Menge aller
(ungerichteten) Graphen mit $n$ Ecken. \\
Den vollständigen Graphen auf $n$ Ecken bezeichnen wir
mit $K_n$. \\
Ist $G \in \mathcal{G}_n$ ein Subgraph von $G' \in \mathcal{G}_n$,
so schreiben wir $G \subseteq G$ oder $G' \supseteq G$. Ist $G$ ein
echter Subgraph von $G'$ (d.h. $E(G) \neq E(G')$), dann schreiben
wir $G \subset G'$ bzw. $G' \subset G$.
Für $G' = (V, E \cup \{e\})$ schreiben wir vereinfachend
$G' = G + E$ und für $G' = (V, E \backslash \{e\})$ vereinfachend
$G' = G - e$.


\begin{definition}[Graph-Eigenschaft]
Eine Teilmenge $P_n \subseteq \mathcal{G}_n$ der Graphen mit
$n$ Ecken heißt \emph{Graph-Eigenschaft auf $n$ Ecken},
wenn sie invariant unter Isomorphie ist,
d.h. wenn für zwei isomorphe Graphen $G, G'$ gilt:
$G \in P \iff G' \in P$.
\end{definition}
Statt $G \in P_n$ sagen wir auch: $G$ erfüllt die Eigenschaft $P_n$.


\begin{definition}[Monotone Graph-Eigenschaft]
Eine Graph-Eigenschaft $P_n$ heißt \emph{monoton}, wenn das
Hinzufügen von Kanten die Eigenschaft erhält,
d.h. wenn ein Graph
$G' \in \mathcal{G}_n$ ein Supergraph von
$G \in \mathcal{G}_n$ ist, so gilt 
$G \in P_n \implies G' \in P_n$.
\end{definition}

\begin{example}[Monotone Graph-Eigenschaft]
\label{exmpl:Monotonie}
Wir betrachten die folgende Graph-Eigenschaft 
$P_4 \subseteq \mathcal{G}_4$ auf $4$ Ecken:
$$P_4 := \{ G \in \mathcal{G}_4 \ | \ G \text{ enthält den Subgraphen } K_3 \}$$
Diese Eigenschaft ist \emph{monoton}, da wenn 
$G \in P_4$ gilt, $G$ den Subgraphen $K_3$
enthält, woraus folgt, dass auch jeder Supergraph $G'\supseteq G$
den Subgraphen $K_3$ enthält. 
\end{example}

Im folgenden werden wir uns auf monotone Graph-Eigenschaften beschränken.
Um einige degenerierte Fälle auszuschließen, beschränken
wir uns auch auf \emph{nichttriviale} Eigenschaften.
\begin{definition}[Nichttriviale Graph-Eigenschaft]
Eine monotone Graph-Eigenschaft $P_n$ heißt \emph{nichttrivial},
wenn der leere Graph $E_n$ nicht in $P_n$ enthalten ist und
$P_n\neq \emptyset$ gilt.
\end{definition}
Die Bedingung $E_n \notin P_n$ bedeutet, dass $P_n$ nicht
alle Graphen auf $n$ Ecken beinhaltet. In diesem Fall würde
es keinen Sinn machen, einen Algorithmus berechnen zu lassen,
ob ein gegebener Graph die Eigenschaft erfüllt, da das Ergebnis
unabhängig vom Graphen wäre.

\begin{definition}[Minimaler Graph]
Ein Graph $G \in \mathcal{G}_n$ heißt
\emph{minimaler Graph der montonen Graph-Eigenschaft $P_n$},
wenn $G \in P_n$ gilt, aber jeder echte Subgraph 
$G' \subset G$ die Eigenschaft $P_n$ nicht erfüllt.
\end{definition}

In Beispiel \ref{exmpl:Monotonie} wäre 
\begin{center}
\begin{tikzpicture}[main_node/.style={circle,fill=black,minimum size=0.8em,inner sep=2pt]}]

    \node[main_node] (1) at (0,0) {};
    \node[main_node] (2) at (-0.5, -0.75)  {};
    \node[main_node] (3) at (0.5, -0.75) {};
    \node[main_node] (4) at (1.2, -0.3) {};

    \draw (1) -- (2) -- (3) -- (1);
\end{tikzpicture}
\end{center}

der bis auf Isomorphie eindeutige \emph{minimale} 
Graph von $P_4$, da das Entfernen einer Kante
den Subgraphen $K_3$ zerstören würde.

\begin{definition}[Minimale Graphenmenge $\Min(P_n)$]
Die Menge der minimalen Graphen der monotonen Graph-Eigenschaft
$P_n$ heißt:
$$\Min(P_n) := \{ G\in P_n \ | \ G \textup{ ist minimaler Graph von } P_n\}$$
\end{definition}

Die Menge $\Min(P_n)$ charakterisiert die
Eigenschaft vollständig, wie folgender Satz zeigt:

\begin{Satz}[$\Min(P_n)$ legt $P_n$ eindeutig fest]
Sind $P_n, P'_n \subseteq \mathcal{G}_n$ zwei monotone 
Graph-Eigenschaften, so gilt
$\Min(P_n) = \Min(P'_n)$ genau dann, wenn $P_n = P'_n$.
\end{Satz}
\begin{proof} \hfill
\begin{description}
\item[$\boldsymbol{\Min(P_n) = \Min(P'_n) \implies P_n = P'_n}$]
\hfill \\
Sei $G \in P_n$ beliebig. Wir zeigen dann, dass auch $G \in P'_n$
gilt. Aus Symmetriegründen folgt dann, dass für ein beliebiges 
$G' \in P'_n$ gilt: $G' \in P_n$, woraus die Gleichheit der
Eigenschaften $P_n = P'_n$ folgt. \\
Wir setzen $G_0 := G$. Solange es möglich ist, wählen wir nun
eine Kante $e \in E(G_i)$, sodass für $G_{i+1} := G_i - e$  
weiterhin $G_{i+1} \in P_n$ gilt. \\
Es gibt nun ein $i$, für das es nicht mehr möglich ist,
aus $G_i$ eine Kante zu entfernen und dabei die Eigenschaft
zu erhalten (spätestens, wenn $G_i$ leer ist).
Der Graph $G_i$ ist dann per Konstruktion ein minimaler
Graph, folglich gilt $G_i \in \Min(P_n)$. Aufgrund der
Voraussetzung $\Min(P_n) = \Min(P'_n)$ gilt auch 
$G_i \in \Min(P'_n)$. Da die Eigenschaft $P'_n$ monoton ist,
und $G_i \subseteq G$, gilt dann auch $G_i \in P'_n$,
wie gefordert.
\item[$\boldsymbol{P_n = P'_n \implies \Min(P_n) = \Min(P'_n)}$]
\hfill \\
Wegen $P_n = P'_n$ ist $G \in \mathcal{G}_n$ offensichtlich
genau dann ein minimaler Graph von $P_n$, wenn $G$ ein 
minimaler Graph von $P'_n$ ist. Daraus folgt 
$\Min(P_n) = \Min(P'_n)$.
\end{description}
\end{proof}
Der vorherige Satz ermöglicht uns, eine
monotone Eigenschaft einfacher zu beschreiben. 
Für die monotone Graph-Eigenschaft $P_n\subseteq \mathcal{G}_n$
mit der Menge an minimalen Graphen $\mathcal{H} = \Min(P_n)$
schreiben wir $\operatorname{P}_n(\mathcal{H})$. Die Eindeutigkeit dieser
Schreibweise folgt aus dem vorherigen Satz. \\
Dies macht das Formulieren von Eigenschaften sehr viel einfacher:
Die Eigenschaft aus Beispiel \ref{exmpl:Monotonie} lässt sich
so schreiben als $\operatorname{P}_4(\{K_3\})$.


\subsection{Abfragekomplexität}
\label{sec:queryComplexity}

Wir führen nun die ersten algorithmischen Begriffe ein. \\
Da wir uns nur mit der Abfragekomplexität beschäftigen,
vereinfachen wir unser Berechnungsmodell: \\
Einen Algorithmus stellen wir als Entscheidungsbaum dar.
Die Knoten sind hierbei mit einer Kante bezeichnet, die
abgefragt wird. Jeder Knoten hat zwei Kante, die mit
''ja'' und ''nein'' beschriftet sind, dies steht für
die Antwort auf die Abfrage. Die Blatt-Knoten sind
zusätzlich mit ''ja'' und ''nein'' beschriftet,
dies steht für den Rückgabewert des Algorithmus.
Zu beachten ist, dass der Algorithmus nur für eine
Eingabegröße, das heißt für eine Eckenanzahl $n$,
festgelegt ist.\\
Wir sagen nun, dass ein Algorithmus $\mathcal{A}$
die Graph-Eigenschaft $P_n$ \emph{entscheidet}, wenn
für jeden Input $G \in \mathcal{G}_n$ der Blatt-Knoten
des zugehörigen Pfades des Entscheidungsbaums genau
dann mit ''ja'' beschriftet ist, wenn $G \in P_n$ gilt.

\begin{example} \ \\*
\label{exmpl:decisionTree}
\begin{center}
\begin{tikzpicture} [
    level 1/.style = {sibling distance=6cm},
    level 2/.style = {sibling distance=2cm}, 
    level 3/.style = {sibling distance=2cm}, 
]
\tikzstyle{every node}=[circle,draw]

\node [circle, draw] {$(1,2)$}
  child {  node {$(1,3)$} 
    child { node {Ja} edge from parent node[left,draw=none] {ja} }
    child { node {$(2,3)$}
      child { node {Ja} edge from parent node[left,draw=none] {ja} }
      child { node {Nein} edge from parent node[right,draw=none] {nein} }
      edge from parent node[right,draw=none] {nein} 
    }
    edge from parent node[left,draw=none] {ja}
  }
  child { node {$(2,3)$}
    child { node {$(1,3)$}
      child { node{Ja} edge from parent node[left,draw=none] {ja} }
      child { node{Nein} edge from parent node[right,draw=none] {nein} }
      edge from parent node[left,draw=none] {ja}
    }
    child { node {Nein} edge from parent node[right,draw=none] {nein} }
    edge from parent node[right,draw=none] {nein} 
  };
\end{tikzpicture}
\end{center}
Der hier dargestellte Entscheidungsbaum entscheidet
die monotone Graph-Eigenschaft 
$P_3 := \big\{ G \in \mathcal{G}_n \ \big| \ |E(G)| \geq 2 \big\}$,
d.h. ob der Graph mindestens $2$ Kanten hat.
Man sieht, dass die Anzahl an Abfragen von
dem Input abhängt.
\end{example}

Wir können nun unseren zentralen Begriff definieren.
\begin{definition}[Abfragekomplexität für einen Input]
Die \emph{Abfragekomplexität} $C(\mathcal{A},G)$ eines
Algorithmus $\mathcal{A}$ für den Input $G$ ist
die Länge des zu $G$ gehörenden Pfades des
Entscheidungsbaumes.
\end{definition}
Die Abfragekomplexität eines Algorithmus definieren
wir nun als Worst-Case-~Komplexität.
\begin{definition}[Abfragekomplexität eines Algorithmus]
Die \emph{Abfragekomplexität} $C(\mathcal{A})$ eines
Algorithmus $\mathcal{A}$ ist
$$ C(\mathcal{A}) := \max_{G \in \mathcal{G}_n} C(\mathcal{A},G)$$
\end{definition}
Der in Beispiel \ref{exmpl:decisionTree} dargestellte
Algorithmus hat eine Abfragekomplexität von $3$, da
der längste Pfad die Länge $3$ hat. \\
Nun können wir die Abfragekomplexität unabhängig
von einem bestimmten Algorithmus definieren.
\begin{definition}
Die \emph{Abfragekomplexität} $C(P_n)$ einer Graph-Eigenschaft
$P_n$ ist
$$ C(P_n) := \min_{\mathcal{A} \ {\rm entscheidet}\  P_n} C(\mathcal{A})$$
\end{definition}

Wir sind nun in der Lage, die Aanderaa-Karp-Rosenberg-Vermutung
exakt zu formulieren:
\footnote{vgl. \cite{Lovasz}}
\begin{conjecture}[Aanderaa-Karp-Rosenberg]
Jede monotone nichttriviale Graph-Eigenschaft $P_n$
hat eine Abfragekomplexität von
$$C(P_n) = \frac{n(n-1)}{2}$$
\end{conjecture}
Die Aanderaa-Karp-Rosenberg-Vermutung sagt also aus,
das bei allen monotonen Graph-Eigenschaften im Worst-Case
alle Kanten abgefragt werden müssen (denn ein Graph mit
$n$ Ecken hat genau $\frac{n(n-1)}{2}$ Kanten).

\subsection{Randomisierte Abfragekomplexität}

Bisher haben wir uns nur mit \emph{deterministischer}
Abfragekomplexität beschäftigt, d.h. die betrachteten
Algorithmus hatten keinen Zufall zur Verfügung.
Da randomisierte Algorithmen deterministischen Algorithmen
oft überlegen sind, müssen wir dies auch für
die Abfragekomplexität untersuchen.
% Vielleicht Zitat einfügen für
% Problem, bei dem randomisierte Algorithmen klar
% überlegen sind.
Wir definieren hierfür zunächst einen randomisierten
Algorithmus, um dann dessen Komplexität zu definieren
\footnote{vgl. \cite{Groeger}}.
\begin{definition}[Randomisierter Algorithmus]
Ein \emph{randomisierter Algorithmus}, der eine
Eigenschaft $P_n$ entscheidet, ist eine
Wahrscheinlichkeitsverteilung von deterministischen
Algorithmen, die $P_n$ entscheiden. Formal: eine Abbildung
$$ p_\mathcal{A}: \{ \mathcal{A} \ \textup {deterministisch} \ | \
         \mathcal{A} \ {\rm entscheidet} \ P_n \} \to \mathbb{R} $$
mit $\sum_\mathcal{A} p_\mathcal{A}(\mathcal{A}) = 1$.
\end{definition}

Das Ausführen eines randomisierten Algorithmus findet
dann so statt: Zu Beginn wird, mit den entsprechenden
Wahrscheinlichkeiten, ein deterministischer Algorithmus
ausgewählt, der dann ausgeführt wird.
Die randomisierte Abfragekomplexität ist dann der
Erwartungswert für die benötigte Anzahl an Abfragen.

\begin{definition}[Randomisierte Abfragekomplexität für einen Input]
\label{def:randComplInput}
Die \emph{randomisierte Abfragekomplexität} $C_R(P_n)$ eines randomisierten
Algorithmus $p_\mathcal{A}$, für den Input $G\in \mathcal{G}_n$, ist:
$$ C_R(p_\mathcal{A}, G) := 
\sum_\mathcal{A} p_\mathcal{A}(\mathcal{A}) \cdot C(\mathcal{A}, G) $$
\end{definition}
Analog definieren wir nun die randomisierte Abfragekomplexität
eines Algorithmus:
\begin{definition}[Randomisierte Abfragekomplexität eines Algorithmus]
Die \emph{randomisierte Abfragekomplexität} eines randomisierten
Algorithmus $\mathcal{A}$ ist:
$$ C_R(\mathcal{A}) := \max_{G\in\mathcal{G}_n} C_R(\mathcal{A}, G) $$
\end{definition}
Analog zum deterministischen Fall können wir nun die
\emph{randomisierte} Abfragekomplexität einer Graph-Eigenschaft
definieren:
\begin{definition}[Randomisierte Abfragekomplexität einer Graph-Eigenschaft]
\label{def:randComplProp}
Die \emph{randomisierte Abfragekomplexität} einer Graph-Eigenschaft
$P_n$ ist:
$$ C_R(P_n) := \min_{\mathcal{A}_R}\ C(\mathcal{A}_R)$$
wobei $\mathcal{A}_R$ aus allen randomisierten Algorithmen,
die $P_n$ entscheiden, gewählt wird.
\end{definition}

\section{Untere Schranken für die Abfragekomplexität}

\subsection{... anhand eines minimalen Graphen}

Wir zeigen nun einige einfache untere Schranken
für die Abfragekomplexität, die auf minimalen
Graphen basieren. Diese Aussagen ermöglichen uns
später, konkretere untere Schranken zu beweisen.
\footnote{Ein ähnlicher Ansatz wird verfolgt von: \cite{Groeger}}
\begin{Satz}[Größe des minimalen Graphen ist untere Schranken]
\label{thm:minDetLowerBound}
Sei $H\in \mathcal{G}_n$ ein minimaler Graph der monotonen
Graph-Eigenschaft $P_n$. Dann gilt für jeden deterministischen
Algorithmus $\mathcal{A}$, der $P_n$ entscheidet:
$$ C(\mathcal{A,H}) \geq |E(H)| $$.
\end{Satz}
\begin{proof}
Wir führen einen Widerspruchsbeweis. \\
Angenommen $ C(\mathcal{A},H) < |E(H)| $.
Dann gibt es eine Kante $e\in H$,
die von $\mathcal{A}$ nicht abgefragt wird. Entfernen wir
diese Kante, so erhalten wir den Graphen $H' = H - e$, der,
da $H$ ein minimaler Graph ist, die Eigenschaft $P$ nicht
erfüllt. $\mathcal{A}$ gibt jedoch für $H$ und $H'$ das gleiche
Ergebnis zurück, da die sie unterscheidende Kante von $\mathcal{A}$
nicht abgefragt wird. Folglich entscheidet $\mathcal{A}$ die
Eigenschaft $P_n$ nicht korrekt. Dies ist ein Widerspruch zur
Voraussetzung. Folglich muss $ C(\mathcal{A,H}) \geq |E(H)| $ gelten. 
\end{proof}
Der Satz sagt nicht nur aus, dass die Abfragekomplexität
der Eigenschaft von unten beschränkt ist, sondern auch, dass
es einen bestimmten Input gibt, für den eine bestimmte Anzahl
an Abfragen benötigt werden, unabhängig davon, welchen Algorithmus
wir wählen. Dies bedeutet, dass ein randomisierter Algorithmus
auch diese Anzahl an Abfragen benötigt:
\begin{corollary}[Minimaler Graph liefert untere Schranke für 
                  randomisierte Abfragekomplexität]
\label{cor:MinGraphRandCompl}
Sei $H\in \mathcal{G}_n$ ein minimaler Graph der monotonen
Graph-Eigenschaft $P_n$. Dann gilt:
$$C_R(P_n) \geq |E(H)|$$.
\end{corollary}
\begin{proof}
Sei $p_\mathcal{A}$ ein beliebiger randomisierter Algorithmus,
der $P_n$ entscheidet.
Nach Definition \ref{def:randComplInput} gilt: 
$ C_R(p_\mathcal{A}, H) = 
\sum_\mathcal{A} p_\mathcal{A}(\mathcal{A}) \cdot C(\mathcal{A}, H) $.
Wegen Satz \ref{thm:minDetLowerBound} gilt $C(\mathcal{A}, H) \geq |E(H)|$
für alle deterministischen Algorithmen $\mathcal{A}$. Einsetzen ergibt:
$$ C_R(p_\mathcal{A}, H) \overset{\textup{Def.} \ref{def:randComplInput}} {=}
\sum_\mathcal{A} p_\mathcal{A}(\mathcal{A}) \cdot C(\mathcal{A}, H) 
\overset{\textup{Satz } \ref{thm:minDetLowerBound}} {\geq}
\sum_\mathcal{A} p_\mathcal{A}(\mathcal{A}) \cdot |E(H)| =
|E(H)| $$
Mit Definition \ref{def:randComplProp} erhalten wir dann
$$ C_R(P_n) \overset{\textup{Def. } \ref{def:randComplProp}} {=} 
\min_{p_\mathcal{A}}\ C(p_\mathcal{A}) \geq |E(H)|$$
\end{proof}

Wie man sieht, kann mit minimalen Graphen einfach untere Schranken
für die Abfragekomplexität zeigen. Die Anzahl an Kanten $|E(H)|$
kann jedoch klein sein, sodass die untere Schranke nicht viel wert ist.
Im folgenden Abschnitt betrachten wir daher ein anderes Konzept.

\subsection{... anhand eines kantenmaximalen Graphen}

Wir führen daher nun das Konzept des kantenmaximalen Graphen ein,
welches gewissermaßen \emph{dual} zum Konzept des minimalen Graphen
ist. Wir wollen damit wieder eine untere Schranke zeigen.
\begin{definition}[Kantenmaximaler Graph
\footnote{vgl. \cite[S.12]{diestel}}]
Ein Graph $G\in \mathcal{G}_n$ heißt \emph{kantenmaximaler Graph}
der monotonen Graph-Eigenschaft $P_n$, wenn $G\notin P_n$ gilt,
aber für alle Kanten $e\notin G$ gilt: $G + e \in P_n$.
\end{definition}
Kantenmaximale Graphen sind also Graphen, die die Eigenschaft
nicht erfüllen, bei dem das Hinzufügen einer beliebigen
Kante aber dafür sorgt, dass die Eigenschaft erfüllt wird.
% Hier vielleicht Beispiel einfügen für kantenmaximalen Graphen ?

\begin{example}[Kantenmaximaler Graph]
Ein kantenmaximaler Graph der Eigenschaft $\operatorname{P}_4(\{K_3\})$
aus Beispiel \ref{exmpl:Monotonie} ist folgender Graph:

\begin{center}
\begin{tikzpicture}[main_node/.style={circle,fill=black,minimum size=0.8em,inner sep=2pt]}]

    \node[main_node] (1) at (0,0) {};
    \node[main_node] (2) at (1, 0)  {};
    \node[main_node] (3) at (1, 1) {};
    \node[main_node] (4) at (0, 1) {};

    \draw (1) -- (2) -- (3) -- (4) -- (1);
\end{tikzpicture}
\end{center}


\end{example}

Mithilfe von kantenmaximalen Graphen können wir auch untere
Schranken beweisen, wie wir dies mit minimalen Graphen
in Satz \ref{thm:minDetLowerBound} getan haben. Hier ist
jedoch nicht die Anzahl der Kanten des Graphen ausschlaggebend,
sondern die Anzahl der \emph{fehlenden} Kanten.

\begin{Satz}[Kantenmaximaler Graph liefert untere Schranke]
\label{thm:EdgeMaxGraphLowerBound}
Sei $G\in \mathcal{G}_n$ ein kantenmaximaler Graph der monotonen
Graph-Eigenschaft $P_n \subseteq \mathcal{G}_n$.
Dann gilt für jeden deterministischen Algorithmus $\mathcal{A}$,
der $P_n$ entscheidet: 
$$ C(\mathcal{A}, G) \geq \binom{n}{2} - |E(G)| $$
\end{Satz}
\begin{proof}
Der Beweis erfolgt analog zu dem von Satz \ref{thm:minDetLowerBound},
wobei nun die Kanten, die nicht zum Graphen gehören, vom Algorithmus
abgefragt werden müssen.
\end{proof}
Wir erhalten nun analog zum Fall der minimalen Graphen eine untere
Schranke für die randomisierte Abfragekomplexität:
\begin{corollary} [Kantenmaximaler Graph liefert untere Schranke
für die randomisierte Abfragekomplexität]
\label{thm:EdgeMaximalRandCompl}
Sei $G\in\mathcal{G}_n$ ein kantenmaximaler Graph der monotonen
Graph-Eigenschaft $P_n \subseteq \mathcal{G}_n$.
Dann gilt
$$ C_R(P_n) \geq \binom{n}{2} - |E(H)| $$
\end{corollary}
\begin{proof}
Der Beweis erfolgt analog zum Beweis von Korollar \ref{cor:MinGraphRandCompl}
unter Verwendung von Satz \ref{thm:EdgeMaxGraphLowerBound}.
\end{proof}

\section{Konkrete Kriterien für untere Schranken}
Die bisher gezeigten unteren Schranken sind schwer auf konkrete
Fälle anzuwenden, da zuerst passende minimale Graphen oder kantenmaximale
Graphen gefunden werden müssen, die zu der Eigenschaft gehören.
In diesem Abschnitt entwickeln wir daher einige einfach zu überprüfende
Kriterien für Graph-Eigenschaften, aus denen dann eine gute
untere Schranke folgt. \\
Wir beschränken uns hierfür auf Eigenschaften, bei denen einer
der minimalen Graphen nur wenige Ecken mit positivem Grad hat
im Vergleich zur gesamten Eckenanzahl. Ein Beispiel dafür wäre
die Eigenschaft $\operatorname{P}_{100}(\{ \ \Square \ \})$,
denn hier hat der minimale Graph nur $4$ Ecken mit positivem
Grad, aber Eingaben haben $100$ Ecken. \\
Wir gehen folgendermaßen vor: Wir konstruieren für Eigenschaften,
die gewisse Kriterien erfüllen, kantenmaximale Graphen mit 
relativ wenigen Kanten. Mithilfe von Korrollar 
\ref{thm:EdgeMaximalRandCompl} erhalten wir so eine untere Schranke
für die randomisierte Abfragekomplexität.

\subsection{Konstruktion kantenmaximaler Graphen}
Die Hauptidee: Wir nehmen einen minimalen Graphen (der eine
relativ geringe Eckenanzahl hat) und wählen zwei benachbarte Ecken
$u$ und $v$. Wir konstruieren nun einen Graphen, indem wir aus dem
minimalen Graphen die Ecken $u$ und $v$ herauslöschen und dann eine große
Anzahl von Kopien von $u$ und $v$ hinzufügen, jedoch ohne die Kante
zwischen $u$ und $v$. \\
Fügt man nun eine beliebige Kante zwischen einer Kopie von $u$ und einer
Kopie von $v$ ein, dann entsteht ein minimaler Graph. Wenn der
konstruierte Graph die Eigenschaft also nicht erfüllt, so sorgt 
ein Hinzufügen einer Kante dafür, dass die Eigenschaft erfüllt wird.
Folglich müssen alle diese entscheidenden Kanten abgefragt werden.
Da die Anzahl der in Frage kommenden Kanten groß ist, erhalten
wir eine gute untere Schranke für die Abfragekomplexität.
Fügt man alle Kanten hinzu, deren Ergänzung die Eigenschaft
nicht hervorruft, so erhält man sogar einen kantenmaximalen Graphen,
mit dem man dann mithilfe von Korollar \ref{thm:EdgeMaximalRandCompl}
direkt eine untere Schranke bekommt.
Im folgendem Beispiel führen wir diese Konstruktion einmal
exemplarisch durch.

% Hier Beispiel einfügen für die Konstruktion
\begin{example}[Konstruktion eines kantenmaximalen Graphen]
Wir betrachten die Graph-Eigenschaft $P_6(\{\Square\})$: ob der
Graph einen $4$-Kreis enthält.
Wir wählen nun zwei benachbarte Ecken $u$ und $v$ des minimalen
Graphen aus:
\begin{center}
\begin{tikzpicture}[main_node/.style={draw, circle, minimum size=0.8em,inner sep=2pt]}]

    \node[main_node] (1) at (0,0) {};
    \node[main_node] (2) at (1, 0)  {v};
    \node[main_node] (3) at (1, 1) {u};
    \node[main_node] (4) at (0, 1) {};

    \draw (1) -- (2) -- (3) -- (4) -- (1);
\end{tikzpicture}
\end{center}
Nun löschen wir die Kante zwischen $u$ und $v$ und fügen
in diesem Fall eine Kopie der Ecke $u$ und eine Kopie
der Ecke $v$ hinzu, sodass wir $6$ Ecken haben, da es 
sich um eine Eigenschaft auf $6$ Ecken handelt:
\begin{center}
\begin{tikzpicture}[main_node/.style={draw, circle, minimum size=1.5em,inner sep=2pt]}]

    \node[main_node] (1) at (0,0) {};
    \node[main_node] (2) at (2, -1)  {v};
    \node[main_node] (3) at (2, 3) {u};
    \node[main_node] (4) at (0, 2) {};
    
    \node[main_node] (5) at (3.5, 2) {u'};
    \node[main_node] (6) at (3.5, 0) {v'};

    \draw (1) -- (2); 
    \draw (3) -- (4) -- (1);
    \draw (5) -- (4);
    \draw (6) -- (1);
    \draw[dotted] (2) -- (3);
    \draw[dotted] (2) -- (5);
    \draw[dotted] (5) -- (6);
    \draw[dotted] (3) -- (6);
\end{tikzpicture}
\end{center}
Die Kanten, deren Hinzufügen einen Subgraphen \Square \ entstehen
lässt, werden hier gestrichelt dargestellt. Der konstruierte
Graph selbst enthält keinen solchen Subgraphen (Wie wir später
sehen werden, liegt dies daran, dass der minimale Graph regulär
ist). Um aus diesem konstruierten Graphen einen kantenmaximalen
Graphen zu machen, müssen nun noch Kanten hinzugefügt werden,
bis das Hinzufügen einer beliebigen, nicht zum Graphen gehörenden
Kante, einen Subgraphen entstehen lässt. Die Wahl der hinzugefügten
Kanten ist jedoch nicht eindeutig. Eine Möglichkeit ist
die folgende:
\begin{center}
\begin{tikzpicture}[main_node/.style={draw, circle, minimum size=1.5em,inner sep=2pt]}]

    \node[main_node] (1) at (0,0) {};
    \node[main_node] (2) at (2, -1)  {v};
    \node[main_node] (3) at (2, 3) {u};
    \node[main_node] (4) at (0, 2) {};
    
    \node[main_node] (5) at (3.5, 2) {u'};
    \node[main_node] (6) at (3.5, 0) {v'};

    \draw (1) -- (2); 
    \draw (3) -- (4) -- (1);
    \draw (5) -- (4);
    \draw (6) -- (1);
    
    \draw (2) -- (6);
    \draw (3) -- (5);
    
    \draw[dotted] (2) -- (3);
    \draw[dotted] (2) -- (5);
    \draw[dotted] (5) -- (6);
    \draw[dotted] (3) -- (6);
    
    % hinzugefügt gegenüber vorherigem Graphen.
    \draw[dotted] (5) -- (1);
    \draw[dotted] (6) -- (4);
\end{tikzpicture}
\end{center}
\end{example}

Die Konstruktion des Graphen formalisieren
wir nun:
\begin{definition}
[Duplizierungs-Graph $\Dupl(G, u, v, n)$]
Der Graph, der aus $G$ entsteht, indem man
die Kante zwischen $u\in V(G)$ und $v\in V(G)$ löscht
und dann $n\in \mathbb{N}$ Kopien von $u$ und $n$
Kopien von $v$ hinzufügt$, bezeichnen wir mit
$\Dupl(G, u, v, n)$.
\end{definition}

Damit wir einen kantenmaximalen Graphen erhalten, darf
der konstruierte Duplizierungs-Graph keinen minimalen Graphen
als Subgraphen enthalten. Also darf das Hinzufügen
von Kopien von Ecken keinen neuen minimalen Graphen
als Subgraphen erzeugen. Dies formalisieren wir 
folgendermaßen:
\begin{definition}[Duplizierungs-invarianter Graph]
Ein Graph $G$ heißt \emph{duplizierungs-invariant},
wenn es zwei benachbarte Ecken $u,v\in G$ gibt, 
sodass der Duplizierungsgraph $\Dupl(G, u, v, n)$
für alle Werte von $n\in \mathbb{N}$, den Graphen
$G$ nicht als Subgraphen enthält.
\end{definition}

\subsection{Kriterien für das Gelingen der Konstruktion}
% z.B. minimaler Grad, maximale Clique, etc.

\subsection{Limitierungen dieses Ansatzes}
Im vorherigen Abschnitt haben wir gezeigt, dass viele Eigenschaften,
die einen  minimalen Graphen mit wenigen Ecken haben, einen kantenmaximalen
Graphen mit wenigen Kanten haben. Es stellt sich nun die Frage,
ob man dies so weit verallgemeinern kann, dass alle Eigenschaften
mit minimalen Graphen mit wenigen Kanten auch einen kantenmaximalen
Graphen mit wenigen Kanten haben. Daraus würde eine allgemeine
untere Schranke für die randomisierte Abfragekomplexität folgen.
Wir zeigen nun jedoch, dass dies nicht allgemein gilt, indem wir
eine Eigenschaft finden, die einen minimalen Graphen mit wenigen
Kanten hat und dennoch nur kantenmaximale Graphen mit vielen Kanten. \\
Dies ist folgende Familie von Eigenschaften:
$$ P'_n := \{ \ G \in \mathcal{G}_n \ 
| \ \exists u\in V(G) \textup{ mit} \deg(u) = n-1 \ \}$$
In Worten: Die Eigenschaft, dass es eine Ecke gibt,
die zu allen anderen Ecken eine Kante hat.
Die Eigenschaft $P'_n$ hat einen minimalen Graphen mit
$n-1$ Kanten. Die Anzahl der Kanten des minimalen Graphen
liefert also keine gute untere Schranke für die Abfragekomplexität.
Wir zeigen nun, dass alle kantenmaximalen Graphen von $P'_n$
eine sehr hohe Kantenanzahl haben. Also folgt auch aus der Kantenanzahl
der kantenmaximalen Graphen keine gute untere Schranke.
\begin{Satz}[Alle kantenmaximalen Graphen von $P'_n$ 
             haben eine hohe Kantenanzahl]
Sei $G\in \mathcal{G}_n$ ein beliebiger kantenmaximaler Graph
von $P'_n$. Dann gilt
$$ |E(G)| \geq \binom{n}{2} - n $$
\end{Satz}
\begin{proof}

\end{proof}


\chapter{Verallgemeinerung auf symmetrischen Eigenschaften}

\section{Allgemeine symmetrische Eigenschaften}
% Definition etc.

\section{Untere Schranken für die Abfragekomplexität}
% Verallgemeinerte AKR-Vermutung, Beweis von Rivest für
% transitive Symmetriegruppen und Primzahlpotenzen
% Zeige, dass Transitivität notwendiges Kriterium ist.

\section{Algebraische Formulierungen}
Dem aufmerksamen Leser ist schon aufgefallen, dass die in 
Abschnitt \ref{sec:queryComplexity} getroffenen Definitionen
zur Abfragekomplexität relativ schwammig ausgefallen sind.
Dies macht es schwierig, die entsprechenden Definitionen
für mathematische Beweise zu verwenden.
Dies wollen wir nun beheben, indem wir eine komplett algebraisch
formulierte Definition für die Abfragekomplexität angeben.
Dies ermöglicht es algebraische Methoden zu verwenden.
% Verschiedene Möglichkeiten, Algorithmen / Abfragekomplexität
% algebraisch zu charakterisieren.


\section{Algebraische Ansätze}
% Gruppenoperationen etc.


\printbibliography
\end{document}
